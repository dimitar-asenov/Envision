<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Envision: Adding a new node type to Envision&#39;s model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Envision
   </div>
   <div id="projectbrief">A visual programming IDE for object-oriented languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dev_tutorials.html">Tutorials for Envision contributors</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Adding a new node type to Envision's model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial we will see how to add a new node type in Envision.</p>
<p>For this we will use the <a class="el" href="classOOModel_1_1IfStatement.html">OOModel::IfStatement</a> node as an example.</p>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>Imagine you had an OO language that has if statements, and support for this feature was missing in Envision. You want to extend Envision's OO model with a new node type representing if statements. Luckily, this is very easy to do if you take advantage of some convenience classes provided by Envision.</p>
<p>To create a new node all you need to do is create a new class that inherits from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Model::Node</a>. It is possible to inherit directly from it, but then you'll have more work to do. The recommended approach, that we'll demonstrate below, is to inherit from <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a> (either directly or indirectly). <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a> provides a whole infrastructure for declaring nodes that makes it really easy to define new node types.</p>
<h1><a class="anchor" id="if_header"></a>
IfStatement.h</h1>
<p>Here is <code>IfStatement.h</code> : </p><div class="fragment"><div class="line"><span class="comment">/***********************************************************************************************************************</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** Copyright (c) 2011, 2014 ETH Zurich</span></div><div class="line"><span class="comment">** All rights reserved.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** Redistribution and use in source and binary forms, with or without modification, are permitted provided that the</span></div><div class="line"><span class="comment">** following conditions are met:</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">**    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following</span></div><div class="line"><span class="comment">**      disclaimer.</span></div><div class="line"><span class="comment">**    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the</span></div><div class="line"><span class="comment">**      following disclaimer in the documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment">**    * Neither the name of the ETH Zurich nor the names of its contributors may be used to endorse or promote products</span></div><div class="line"><span class="comment">**      derived from this software without specific prior written permission.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span></div><div class="line"><span class="comment">** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></div><div class="line"><span class="comment">** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></div><div class="line"><span class="comment">** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span></div><div class="line"><span class="comment">** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">***********************************************************************************************************************/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;Statement.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;../expressions/Expression.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../elements/StatementItemList.h&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceOOModel.html">OOModel</a> {</div><div class="line">   <span class="keyword">class </span>IfStatement;</div><div class="line">}</div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>OOMODEL_API <a class="code" href="classModel_1_1TypedList.html">Model::TypedList&lt;OOModel::IfStatement&gt;</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceOOModel.html">OOModel</a> {</div><div class="line"></div><div class="line"><span class="keyword">class </span>OOMODEL_API IfStatement: <span class="keyword">public</span> <a class="code" href="classCore_1_1Reflect.html">Super&lt;Statement&gt;</a></div><div class="line">{</div><div class="line">   COMPOSITENODE_DECLARE_STANDARD_METHODS(IfStatement)</div><div class="line"></div><div class="line">   ATTRIBUTE(Expression, condition, setCondition)</div><div class="line">   ATTRIBUTE(StatementItemList, thenBranch, setThenBranch)</div><div class="line">   ATTRIBUTE(StatementItemList, elseBranch, setElseBranch)</div><div class="line"></div><div class="line">   public:</div><div class="line">      virtual <span class="keywordtype">bool</span> findSymbols(std::unique_ptr&lt;<a class="code" href="namespaceModel.html">Model</a>::ResolutionRequest&gt; request) const override;</div><div class="line">};</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Let's examine it starting from the top. The first noteworthy bit is:</p>
<p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceOOModel.html">OOModel</a> {</div><div class="line">   <span class="keyword">class </span>IfStatement;</div><div class="line">}</div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>OOMODEL_API Model::TypedList&lt;OOModel::IfStatement&gt;;</div></div><!-- fragment --> In order to be able to put a node into a list of nodes, it is necessary to explicitly instantiate the <a class="el" href="classModel_1_1TypedList.html">Model::TypedList</a> template. This is necessary to support Windows as it can't properly handle templates with static fields otherwise. With this first part in the <code></code>.h file we prevent implicit instantiation. Then the class is explicitly instantiated in the <code></code>.cpp file.</p>
<p>Next comes the class declaration: <div class="fragment"><div class="line"><span class="keyword">class </span>OOMODEL_API IfStatement: <span class="keyword">public</span> <a class="code" href="classCore_1_1Reflect.html">Super</a>&lt;Statement&gt;</div></div><!-- fragment --> The node declaration should use the plug-in's API macro and should inherit directly or indirectly from Node. When specifying the base node type you must do so through the <code>Super</code> template. This is required by the underlying framework. The <code>Super</code> template does two things:</p><ul>
<li>Define a protected type called <code>Super</code> which represents the base class. This makes it possible to simply use <code>Super</code> anywhere where you need to refer to the base class. This is especially helpful when the base class is a long template instantiation. Inheritance via <code>Super</code> is used very often throughout Envision.</li>
<li>Import all constructors of the provided base type, so that your new node can call them.</li>
</ul>
<p>In this case we inherit from <a class="el" href="classOOModel_1_1Statement.html">OOModel::Statement</a>, which itself inherits from <a class="el" href="classOOModel_1_1StatementItem.html">OOModel::StatementItem</a>, which finally inherits from <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a>. Both <a class="el" href="classOOModel_1_1Statement.html">OOModel::Statement</a> and <a class="el" href="classOOModel_1_1StatementItem.html">OOModel::StatementItem</a> are just marker classes that serve only as a common base, grouping other classes together. For the purposes of this tutorial they are not interesting. We really only care about the fact that <a class="el" href="classOOModel_1_1IfStatement.html">OOModel::IfStatement</a> ultimately inherits from <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a>.</p>
<p>Next we notice the first line of the class declaration: <div class="fragment"><div class="line">   COMPOSITENODE_DECLARE_STANDARD_METHODS(IfStatement)</div></div><!-- fragment --> This macro needs to appear as the very first line of the declaration of any node that inherits from <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a>. There is a similar (also mandatory) macro for nodes which inherit directly from Node - <code>NODE_DECLARE_STANDARD_METHODS</code>. Each of these macros needs to be complemented with a couple of macros in the .cpp file:</p>
<p>For <code>COMPOSITENODE_DECLARE_STANDARD_METHODS:</code> </p><ul>
<li><code>DEFINE_COMPOSITE_EMPTY_CONSTRUCTORS</code> </li>
<li><code>COMPOSITEDEFINE_NODE_TYPE_REGISTRATION_METHODS</code> </li>
</ul>
<p>For <code>NODE_DECLARE_STANDARD_METHODS:</code> </p><ul>
<li><code>DEFINE_NODE_EMPTY_CONSTRUCTORS</code> </li>
<li><code>DEFINE_NODE_TYPE_REGISTRATION_METHODS</code> </li>
</ul>
<p>Together these macros save us a ton of writing. They declare many methods for the new node type and setup required data structures. At some point there was an attempt to translate their functionality to templates but the result was more verbose and less flexible so we stuck with the macros.</p>
<p>Next we get to the most interesting bit of the node declaration: <div class="fragment"><div class="line">   ATTRIBUTE(Expression, condition, setCondition)</div><div class="line">   ATTRIBUTE(StatementItemList, thenBranch, setThenBranch)</div><div class="line">   ATTRIBUTE(StatementItemList, elseBranch, setElseBranch)</div></div><!-- fragment --> With the help of the various <code>ATTRIBUTE</code> macros you can easily define what nodes your new composite node will consist of. Here you see the simplest way of using the macro. You only need to specify the type of node, its name (which will also be the name of the getter function for this child), and the name of a setter function. Each of these macro declarations need to have complementing definitions in the <code></code>.cpp file which we'll see later.</p>
<p>Finally we see a method declaration: <div class="fragment"><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">bool</span> findSymbols(std::unique_ptr&lt;Model::ResolutionRequest&gt; request) <span class="keyword">const override</span>;</div></div><!-- fragment --> This is an advanced function for the <a class="el" href="classOOModel_1_1IfStatement.html">OOModel::IfStatement</a> node. For simple nodes you do not need to define this function. The only reason we need it here, is because it is possible to declare a variable inside the condition of an if statement and we need a way to find this variable when resolving references. We won't go into details here as name resolution is a big topic on its own.</p>
<p>This is it really. The essential thing for any <a class="el" href="classModel_1_1CompositeNode.html">Model::CompositeNode</a> derivative is to declare what attribute nodes it consists of. The rest of the code is just boilerplate.</p>
<h1><a class="anchor" id="if_cpp"></a>
IfStatement.cpp</h1>
<p>Here is <code>IfStatement.cpp</code> : </p><div class="fragment"><div class="line"><span class="comment">/***********************************************************************************************************************</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** Copyright (c) 2011, 2014 ETH Zurich</span></div><div class="line"><span class="comment">** All rights reserved.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** Redistribution and use in source and binary forms, with or without modification, are permitted provided that the</span></div><div class="line"><span class="comment">** following conditions are met:</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">**    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following</span></div><div class="line"><span class="comment">**      disclaimer.</span></div><div class="line"><span class="comment">**    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the</span></div><div class="line"><span class="comment">**      following disclaimer in the documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment">**    * Neither the name of the ETH Zurich nor the names of its contributors may be used to endorse or promote products</span></div><div class="line"><span class="comment">**      derived from this software without specific prior written permission.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES,</span></div><div class="line"><span class="comment">** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span></div><div class="line"><span class="comment">** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span></div><div class="line"><span class="comment">** SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span></div><div class="line"><span class="comment">** WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">** OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment">**</span></div><div class="line"><span class="comment">***********************************************************************************************************************/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;IfStatement.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;ModelBase/src/nodes/TypedList.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;OOModel/src/typesystem/OOResolutionRequest.h&quot;</span></div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span>Model::TypedList&lt;OOModel::IfStatement&gt;;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceOOModel.html">OOModel</a> {</div><div class="line"></div><div class="line">DEFINE_COMPOSITE_EMPTY_CONSTRUCTORS(IfStatement)</div><div class="line">DEFINE_COMPOSITE_TYPE_REGISTRATION_METHODS(IfStatement)</div><div class="line"></div><div class="line">DEFINE_ATTRIBUTE(IfStatement, condition, Expression, false, false, true)</div><div class="line">DEFINE_ATTRIBUTE(IfStatement, thenBranch, StatementItemList, false, false, true)</div><div class="line">DEFINE_ATTRIBUTE(IfStatement, elseBranch, StatementItemList, false, false, true)</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> IfStatement::findSymbols(std::unique_ptr&lt;<a class="code" href="namespaceModel.html">Model</a>::ResolutionRequest&gt; request)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">   <span class="keywordflow">if</span> (request-&gt;direction() == SEARCH_UP || request-&gt;direction() == SEARCH_UP_ORDERED)</div><div class="line">   {</div><div class="line">      <span class="keyword">auto</span> ignore = childToSubnode(request-&gt;source());</div><div class="line">      Q_ASSERT(ignore);</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> found{};</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (condition() != ignore)</div><div class="line">         <span class="comment">// Optimize the search by skipping the scope of the source, since we&#39;ve already searched there</span></div><div class="line">         found = condition()-&gt;findSymbols(request-&gt;clone(SEARCH_HERE, <span class="keyword">false</span>)) || found;</div><div class="line">      <span class="comment">// Note that a StatementList (the branches) also implements findSymbols and locally declared variables will be</span></div><div class="line">      <span class="comment">// found there.</span></div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> ((request-&gt;exhaustAllScopes() || !found) &amp;&amp; parent())</div><div class="line">         found = parent()-&gt;findSymbols(request-&gt;clone(SEARCH_UP)) || found;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> found;</div><div class="line">   }</div><div class="line">   <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>All of the things here are just the corresponding definition macros. The only interesting bit is: <div class="fragment"><div class="line">DEFINE_ATTRIBUTE(IfStatement, condition, Expression, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)</div><div class="line">DEFINE_ATTRIBUTE(IfStatement, thenBranch, StatementItemList, false, false, true)</div><div class="line">DEFINE_ATTRIBUTE(IfStatement, elseBranch, StatementItemList, false, false, true)</div></div><!-- fragment --> When defining the registered nodes you need to provide the following information:</p><ul>
<li>The name of the class that you are defining</li>
<li>The name of the attribute you are registering</li>
<li>The name of the type of this attribute</li>
<li>A boolean flag which indicates if this node should be partially loaded by default. This should practically always be <code>false</code> as currently the partial loading implementation is not used.</li>
<li>Another boolean flag which indicates whether this attribute is optional or not. If you set this to <code>false</code>, the attribute is mandatory and calling the getter will always return a valid value. If you do not explicitly set the attribute, a default constructed value will be used. If you set this flag to <code>true</code>, the attribute is optional and calling the getter might return <code>nullptr</code> if the attribute has not been set.</li>
<li>A final flag that indicates whether this attribute should be saved to disk or whether it is transient and should only be used in memory. A value of <code>true</code> will make this attribute persistent. A value of <code>false</code> will make it transient.</li>
</ul>
<h1><a class="anchor" id="allOONodes"></a>
allOOModelNodes.h</h1>
<p>This last step is really just for convenience and is not directly related to creating a new node type.</p>
<p>It is a good idea to provide an easy way for others to use all of the nodes you create. Typically this means creating a header file which simply includes all of the headers files of the nodes you create. In the case of the <a class="el" href="namespaceOOModel.html">OOModel</a> plug-in this file is called <code>allOOModelNodes.h</code>. If you are creating a new node within the <a class="el" href="namespaceOOModel.html">OOModel</a> plug-in please make sure to add its header to <code>allOOModelNodes.h:</code>  <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;statements/IfStatement.h&quot;</span></div></div><!-- fragment --> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
