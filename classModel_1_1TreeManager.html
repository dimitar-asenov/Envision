<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Envision: Model::TreeManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Envision
   </div>
   <div id="projectbrief">A visual programming IDE for object-oriented languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceModel.html">Model</a></li><li class="navelem"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classModel_1_1TreeManager-members.html">List of all members</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Model::TreeManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> class is a management and access entity for a program tree.  
 <a href="classModel_1_1TreeManager.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Model::TreeManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classModel_1_1TreeManager.png" usemap="#Model::TreeManager_map" alt=""/>
  <map id="Model::TreeManager_map" name="Model::TreeManager_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="signals"></a>
Signals</h2></td></tr>
<tr class="memitem:ae8f5f25f8dbfee0da199d49e8694a8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ae8f5f25f8dbfee0da199d49e8694a8fc">nameModified</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node, const QString &amp;oldName)</td></tr>
<tr class="memdesc:ae8f5f25f8dbfee0da199d49e8694a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when the name of a node has changed.  <a href="#ae8f5f25f8dbfee0da199d49e8694a8fc">More...</a><br /></td></tr>
<tr class="separator:ae8f5f25f8dbfee0da199d49e8694a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003d80057998b83de176806c599bf24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a003d80057998b83de176806c599bf24c">nodesModified</a> (QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; modifiedNodes, QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; removedNodes)</td></tr>
<tr class="memdesc:a003d80057998b83de176806c599bf24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted at the end of a modification block.  <a href="#a003d80057998b83de176806c599bf24c">More...</a><br /></td></tr>
<tr class="separator:a003d80057998b83de176806c599bf24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91af5b04ec2b94f3cfeb4f7ec93c8a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a91af5b04ec2b94f3cfeb4f7ec93c8a70">rootNodeSet</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1TreeManager.html#a9cbf0d71e7c5e1193fab5e61fb8bda95">root</a>)</td></tr>
<tr class="memdesc:a91af5b04ec2b94f3cfeb4f7ec93c8a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emitted when a new root node was set.  <a href="#a91af5b04ec2b94f3cfeb4f7ec93c8a70">More...</a><br /></td></tr>
<tr class="separator:a91af5b04ec2b94f3cfeb4f7ec93c8a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad9c7505cbf864e392165cef60ed55719"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ad9c7505cbf864e392165cef60ed55719">TreeManager</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1TreeManager.html#a9cbf0d71e7c5e1193fab5e61fb8bda95">root</a>=nullptr)</td></tr>
<tr class="memdesc:ad9c7505cbf864e392165cef60ed55719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> with the given <em>root</em>.  <a href="#ad9c7505cbf864e392165cef60ed55719">More...</a><br /></td></tr>
<tr class="separator:ad9c7505cbf864e392165cef60ed55719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa38bc53052362a7746b4258fb100b29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#aaa38bc53052362a7746b4258fb100b29">TreeManager</a> (const QString &amp;<a class="el" href="classModel_1_1TreeManager.html#a15ec062a1a6fa4ca0726542401ed8686">name</a>, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1TreeManager.html#a9cbf0d71e7c5e1193fab5e61fb8bda95">root</a>=nullptr)</td></tr>
<tr class="memdesc:aaa38bc53052362a7746b4258fb100b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> with the given <em>name</em> and <em>root</em>.  <a href="#aaa38bc53052362a7746b4258fb100b29">More...</a><br /></td></tr>
<tr class="separator:aaa38bc53052362a7746b4258fb100b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8297bdb5d553898b62bd8971c91c3a46"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a8297bdb5d553898b62bd8971c91c3a46">~TreeManager</a> ()</td></tr>
<tr class="memdesc:a8297bdb5d553898b62bd8971c91c3a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the root node corresponding to the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a>.  <a href="#a8297bdb5d553898b62bd8971c91c3a46">More...</a><br /></td></tr>
<tr class="separator:a8297bdb5d553898b62bd8971c91c3a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ef85c4beb28c42d8df6523315d00d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a26ef85c4beb28c42d8df6523315d00d2">beginExclusiveRead</a> ()</td></tr>
<tr class="memdesc:a26ef85c4beb28c42d8df6523315d00d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins an exclusive read.  <a href="#a26ef85c4beb28c42d8df6523315d00d2">More...</a><br /></td></tr>
<tr class="separator:a26ef85c4beb28c42d8df6523315d00d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aefa4b91245e7540bf1e79964368564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564">beginModification</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1TreeManager.html#a1a919ac640517add285e0d787775ebd7">modificationTarget</a>, const QString &amp;text=QString())</td></tr>
<tr class="memdesc:a2aefa4b91245e7540bf1e79964368564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a modification session.  <a href="#a2aefa4b91245e7540bf1e79964368564">More...</a><br /></td></tr>
<tr class="separator:a2aefa4b91245e7540bf1e79964368564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca7629df3ac48593ad1ac85fcdec48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#af8ca7629df3ac48593ad1ac85fcdec48">canBeModified</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node) const </td></tr>
<tr class="memdesc:af8ca7629df3ac48593ad1ac85fcdec48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node can be modified.  <a href="#af8ca7629df3ac48593ad1ac85fcdec48">More...</a><br /></td></tr>
<tr class="separator:af8ca7629df3ac48593ad1ac85fcdec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a13b318d9f48d7e66da559281588f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a7d6a13b318d9f48d7e66da559281588f">changeModificationTarget</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1TreeManager.html#a1a919ac640517add285e0d787775ebd7">modificationTarget</a>)</td></tr>
<tr class="memdesc:a7d6a13b318d9f48d7e66da559281588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the modification target and possibly the access unit that the current writer is allowed to access.  <a href="#a7d6a13b318d9f48d7e66da559281588f">More...</a><br /></td></tr>
<tr class="separator:a7d6a13b318d9f48d7e66da559281588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fa702cc4143b16250f2dadab98d720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ac2fa702cc4143b16250f2dadab98d720">emitNameModified</a> (<a class="el" href="classModel_1_1NameText.html">NameText</a> *node, const QString &amp;oldName)</td></tr>
<tr class="memdesc:ac2fa702cc4143b16250f2dadab98d720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a nameModified signal to be emitted.  <a href="#ac2fa702cc4143b16250f2dadab98d720">More...</a><br /></td></tr>
<tr class="separator:ac2fa702cc4143b16250f2dadab98d720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b501086dd6bd821cad9033037819b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a241b501086dd6bd821cad9033037819b">endExclusiveRead</a> ()</td></tr>
<tr class="memdesc:a241b501086dd6bd821cad9033037819b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends an exclusive read.  <a href="#a241b501086dd6bd821cad9033037819b">More...</a><br /></td></tr>
<tr class="separator:a241b501086dd6bd821cad9033037819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8a54eae11dc6186a44245cb7e28080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#aac8a54eae11dc6186a44245cb7e28080">endModification</a> (bool tryResolvingReferences=true)</td></tr>
<tr class="memdesc:aac8a54eae11dc6186a44245cb7e28080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a modification session.  <a href="#aac8a54eae11dc6186a44245cb7e28080">More...</a><br /></td></tr>
<tr class="separator:aac8a54eae11dc6186a44245cb7e28080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822220c7500720cfb73cfc9fdac5aa4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a822220c7500720cfb73cfc9fdac5aa4a">isBeingModified</a> () const </td></tr>
<tr class="separator:a822220c7500720cfb73cfc9fdac5aa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d11d3109482a992a93f4c2f560d12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#af29d11d3109482a992a93f4c2f560d12">isOwnedByUndoStack</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node, const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *excludeCommand) const </td></tr>
<tr class="memdesc:af29d11d3109482a992a93f4c2f560d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <em>node</em> is owned by a command in the undo stack.  <a href="#af29d11d3109482a992a93f4c2f560d12">More...</a><br /></td></tr>
<tr class="separator:af29d11d3109482a992a93f4c2f560d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4433cdf4e9d40e637d4b09620a3861a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a4433cdf4e9d40e637d4b09620a3861a9">isPartiallyLoaded</a> () const </td></tr>
<tr class="memdesc:a4433cdf4e9d40e637d4b09620a3861a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this tree has been partially loaded (as a library).  <a href="#a4433cdf4e9d40e637d4b09620a3861a9">More...</a><br /></td></tr>
<tr class="separator:a4433cdf4e9d40e637d4b09620a3861a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8051861435f117ede32287ef207ad671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a8051861435f117ede32287ef207ad671">load</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *<a class="el" href="classModel_1_1TreeManager.html#a464ebd9d99f9664c744fb6f1de356df0">store</a>, const QString &amp;<a class="el" href="classModel_1_1TreeManager.html#a15ec062a1a6fa4ca0726542401ed8686">name</a>, bool loadPartially)</td></tr>
<tr class="memdesc:a8051861435f117ede32287ef207ad671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the manager's tree from the specified persistent store.  <a href="#a8051861435f117ede32287ef207ad671">More...</a><br /></td></tr>
<tr class="separator:a8051861435f117ede32287ef207ad671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a919ac640517add285e0d787775ebd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a1a919ac640517add285e0d787775ebd7">modificationTarget</a> () const </td></tr>
<tr class="separator:a1a919ac640517add285e0d787775ebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec062a1a6fa4ca0726542401ed8686"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a15ec062a1a6fa4ca0726542401ed8686">name</a> ()</td></tr>
<tr class="memdesc:a15ec062a1a6fa4ca0726542401ed8686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the manged tree.  <a href="#a15ec062a1a6fa4ca0726542401ed8686">More...</a><br /></td></tr>
<tr class="separator:a15ec062a1a6fa4ca0726542401ed8686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2994d61f89240710371f946644303d84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a2994d61f89240710371f946644303d84">nodeIdMap</a> () const </td></tr>
<tr class="separator:a2994d61f89240710371f946644303d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95267d50f9f44805cda70179716e841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ac95267d50f9f44805cda70179716e841">nodeIdMap</a> ()</td></tr>
<tr class="separator:ac95267d50f9f44805cda70179716e841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0119abce74eff60b2a22f5367cfad64f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a0119abce74eff60b2a22f5367cfad64f">notifyNodeChange</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0119abce74eff60b2a22f5367cfad64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <em>node</em> to the list of modified nodes during an edit operation or immediately emits a nodesModified signal with the specified node if no modification to the tree is ongoing.  <a href="#a0119abce74eff60b2a22f5367cfad64f">More...</a><br /></td></tr>
<tr class="separator:a0119abce74eff60b2a22f5367cfad64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a383b92bde574517f1b93da8dd5fb82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a1a383b92bde574517f1b93da8dd5fb82">pushCommandOnUndoStack</a> (<a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *command)</td></tr>
<tr class="memdesc:a1a383b92bde574517f1b93da8dd5fb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the specified command on the undo stack and executes it.  <a href="#a1a383b92bde574517f1b93da8dd5fb82">More...</a><br /></td></tr>
<tr class="separator:a1a383b92bde574517f1b93da8dd5fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc63a3c45ca251664a2f52e17c4f74d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#adc63a3c45ca251664a2f52e17c4f74d4">redo</a> ()</td></tr>
<tr class="memdesc:adc63a3c45ca251664a2f52e17c4f74d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redoes the commands executed in the next modification block.  <a href="#adc63a3c45ca251664a2f52e17c4f74d4">More...</a><br /></td></tr>
<tr class="separator:adc63a3c45ca251664a2f52e17c4f74d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbf0d71e7c5e1193fab5e61fb8bda95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a9cbf0d71e7c5e1193fab5e61fb8bda95">root</a> ()</td></tr>
<tr class="memdesc:a9cbf0d71e7c5e1193fab5e61fb8bda95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node for this manager.  <a href="#a9cbf0d71e7c5e1193fab5e61fb8bda95">More...</a><br /></td></tr>
<tr class="separator:a9cbf0d71e7c5e1193fab5e61fb8bda95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ca22fb514d3cb055a395c2ae94c240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a89ca22fb514d3cb055a395c2ae94c240">rootLock</a> ()</td></tr>
<tr class="memdesc:a89ca22fb514d3cb055a395c2ae94c240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock corresponding to the top-most (root) access unit.  <a href="#a89ca22fb514d3cb055a395c2ae94c240">More...</a><br /></td></tr>
<tr class="separator:a89ca22fb514d3cb055a395c2ae94c240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a30036999ba5f1e38a9cb54ec4e4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a99a30036999ba5f1e38a9cb54ec4e4f3">save</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *<a class="el" href="classModel_1_1TreeManager.html#a464ebd9d99f9664c744fb6f1de356df0">store</a>=nullptr)</td></tr>
<tr class="memdesc:a99a30036999ba5f1e38a9cb54ec4e4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the tree in persistent store of the tree manager.  <a href="#a99a30036999ba5f1e38a9cb54ec4e4f3">More...</a><br /></td></tr>
<tr class="separator:a99a30036999ba5f1e38a9cb54ec4e4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aa1bb4b3d0115ca75b3ff33e3730a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ac4aa1bb4b3d0115ca75b3ff33e3730a9">setName</a> (const QString &amp;<a class="el" href="classModel_1_1TreeManager.html#a15ec062a1a6fa4ca0726542401ed8686">name</a>)</td></tr>
<tr class="memdesc:ac4aa1bb4b3d0115ca75b3ff33e3730a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name of the tree.  <a href="#ac4aa1bb4b3d0115ca75b3ff33e3730a9">More...</a><br /></td></tr>
<tr class="separator:ac4aa1bb4b3d0115ca75b3ff33e3730a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4d2090df88eb35010b7ebbc8e1b9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a3f4d2090df88eb35010b7ebbc8e1b9b6">setRoot</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a3f4d2090df88eb35010b7ebbc8e1b9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the root node of this manager to <em>node</em>.  <a href="#a3f4d2090df88eb35010b7ebbc8e1b9b6">More...</a><br /></td></tr>
<tr class="separator:a3f4d2090df88eb35010b7ebbc8e1b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464ebd9d99f9664c744fb6f1de356df0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a464ebd9d99f9664c744fb6f1de356df0">store</a> ()</td></tr>
<tr class="memdesc:a464ebd9d99f9664c744fb6f1de356df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current store for this manager.  <a href="#a464ebd9d99f9664c744fb6f1de356df0">More...</a><br /></td></tr>
<tr class="separator:a464ebd9d99f9664c744fb6f1de356df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042d082dc20453f6cdb0c3b6ccb6e78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a042d082dc20453f6cdb0c3b6ccb6e78b">undo</a> ()</td></tr>
<tr class="memdesc:a042d082dc20453f6cdb0c3b6ccb6e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undoes the commands executed in the previous modification block.  <a href="#a042d082dc20453f6cdb0c3b6ccb6e78b">More...</a><br /></td></tr>
<tr class="separator:a042d082dc20453f6cdb0c3b6ccb6e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a20fdcc1210956ee86d8e5d1f315203c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a20fdcc1210956ee86d8e5d1f315203c6">isOwnedByCommand</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *node, const <a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *cmd, const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *excludeCommand)</td></tr>
<tr class="memdesc:a20fdcc1210956ee86d8e5d1f315203c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether <em>node</em> is transitively owned by <em>cmd</em>.  <a href="#a20fdcc1210956ee86d8e5d1f315203c6">More...</a><br /></td></tr>
<tr class="separator:a20fdcc1210956ee86d8e5d1f315203c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:abb0470001a39781fc3338ce0338a1767"><td class="memItemLeft" align="right" valign="top">QUndoStack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#abb0470001a39781fc3338ce0338a1767">commands</a></td></tr>
<tr class="memdesc:abb0470001a39781fc3338ce0338a1767"><td class="mdescLeft">&#160;</td><td class="mdescRight">The command stack that holds the undo history.  <a href="#abb0470001a39781fc3338ce0338a1767">More...</a><br /></td></tr>
<tr class="separator:abb0470001a39781fc3338ce0338a1767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd56c7199c8a26c9440c071741539be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a1cd56c7199c8a26c9440c071741539be">currentModificationLock</a> {}</td></tr>
<tr class="memdesc:a1cd56c7199c8a26c9440c071741539be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock of the access unit that is responsible for the current modification target node.  <a href="#a1cd56c7199c8a26c9440c071741539be">More...</a><br /></td></tr>
<tr class="separator:a1cd56c7199c8a26c9440c071741539be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2440be1f418c2b5874aefcc6754dfeca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a2440be1f418c2b5874aefcc6754dfeca">currentModificationTarget</a> {}</td></tr>
<tr class="memdesc:a2440be1f418c2b5874aefcc6754dfeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The node that is the top-most ancestor of all other nodes that are currently being modification.  <a href="#a2440be1f418c2b5874aefcc6754dfeca">More...</a><br /></td></tr>
<tr class="separator:a2440be1f418c2b5874aefcc6754dfeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ec8f9a421c5d79e978dde586e1ed7c"><td class="memItemLeft" align="right" valign="top">QReadWriteLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a97ec8f9a421c5d79e978dde586e1ed7c">exclusiveAccess</a></td></tr>
<tr class="memdesc:a97ec8f9a421c5d79e978dde586e1ed7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ReadWrite lock used for exclusive writer or reader access.  <a href="#a97ec8f9a421c5d79e978dde586e1ed7c">More...</a><br /></td></tr>
<tr class="separator:a97ec8f9a421c5d79e978dde586e1ed7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6487047f413f10030f40da709814e8c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a6487047f413f10030f40da709814e8c9">modificationInProgress</a> {}</td></tr>
<tr class="memdesc:a6487047f413f10030f40da709814e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This flag indicates if a modification is currently in progress.  <a href="#a6487047f413f10030f40da709814e8c9">More...</a><br /></td></tr>
<tr class="separator:a6487047f413f10030f40da709814e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fee1c9bb0d3da43999996fa6760150"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a85fee1c9bb0d3da43999996fa6760150">modificationText</a></td></tr>
<tr class="memdesc:a85fee1c9bb0d3da43999996fa6760150"><td class="mdescLeft">&#160;</td><td class="mdescRight">The test message associated with the current modification operation.  <a href="#a85fee1c9bb0d3da43999996fa6760150">More...</a><br /></td></tr>
<tr class="separator:a85fee1c9bb0d3da43999996fa6760150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b15b5d2cc58cadc8a76caf9658c41e6"><td class="memItemLeft" align="right" valign="top">QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a5b15b5d2cc58cadc8a76caf9658c41e6">modifiedTargets</a></td></tr>
<tr class="memdesc:a5b15b5d2cc58cadc8a76caf9658c41e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of all nodes which might have been modified as part of the last modification operation.  <a href="#a5b15b5d2cc58cadc8a76caf9658c41e6">More...</a><br /></td></tr>
<tr class="separator:a5b15b5d2cc58cadc8a76caf9658c41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf58027de7c27192d76d1d73185793e2"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#aaf58027de7c27192d76d1d73185793e2">name_</a></td></tr>
<tr class="memdesc:aaf58027de7c27192d76d1d73185793e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of this manager's tree.  <a href="#aaf58027de7c27192d76d1d73185793e2">More...</a><br /></td></tr>
<tr class="separator:aaf58027de7c27192d76d1d73185793e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed69cb047e6e7bd7f5672b677c5eb467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#aed69cb047e6e7bd7f5672b677c5eb467">nodeIdMap_</a></td></tr>
<tr class="separator:aed69cb047e6e7bd7f5672b677c5eb467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0738c02e6862297717b30650ea16f75d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a0738c02e6862297717b30650ea16f75d">partiallyLoaded_</a> {}</td></tr>
<tr class="memdesc:a0738c02e6862297717b30650ea16f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this tree has been partially loaded (as a library) from a store.  <a href="#a0738c02e6862297717b30650ea16f75d">More...</a><br /></td></tr>
<tr class="separator:a0738c02e6862297717b30650ea16f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00a79b2d5dfb1cea5a5552d6383019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a4b00a79b2d5dfb1cea5a5552d6383019">performedUndoRedo</a> {}</td></tr>
<tr class="memdesc:a4b00a79b2d5dfb1cea5a5552d6383019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if <a class="el" href="classModel_1_1TreeManager.html#a042d082dc20453f6cdb0c3b6ccb6e78b" title="Undoes the commands executed in the previous modification block. ">undo()</a> or <a class="el" href="classModel_1_1TreeManager.html#adc63a3c45ca251664a2f52e17c4f74d4" title="Redoes the commands executed in the next modification block. ">redo()</a> were called during the last modification operation.  <a href="#a4b00a79b2d5dfb1cea5a5552d6383019">More...</a><br /></td></tr>
<tr class="separator:a4b00a79b2d5dfb1cea5a5552d6383019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35082120b91fffc79bd063d5760c28a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#ae35082120b91fffc79bd063d5760c28a">pushedNewCommandsOnTheStack</a> {}</td></tr>
<tr class="memdesc:ae35082120b91fffc79bd063d5760c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if the last modification operation pushed commands on stack.  <a href="#ae35082120b91fffc79bd063d5760c28a">More...</a><br /></td></tr>
<tr class="separator:ae35082120b91fffc79bd063d5760c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1962b73fc09638dcd7d958fc387847c2"><td class="memItemLeft" align="right" valign="top">QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a1962b73fc09638dcd7d958fc387847c2">removedTargets_</a></td></tr>
<tr class="memdesc:a1962b73fc09638dcd7d958fc387847c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of all nodes which have been removed from the tree as part of the last modification operation.  <a href="#a1962b73fc09638dcd7d958fc387847c2">More...</a><br /></td></tr>
<tr class="separator:a1962b73fc09638dcd7d958fc387847c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d96ba6032a8e12941ba266dd3f4ef97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a0d96ba6032a8e12941ba266dd3f4ef97">root_</a> {}</td></tr>
<tr class="memdesc:a0d96ba6032a8e12941ba266dd3f4ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root node for this manager's tree.  <a href="#a0d96ba6032a8e12941ba266dd3f4ef97">More...</a><br /></td></tr>
<tr class="separator:a0d96ba6032a8e12941ba266dd3f4ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5ef275ca019f2dcbe8c3ecdd51d237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#acb5ef275ca019f2dcbe8c3ecdd51d237">rootLock_</a></td></tr>
<tr class="memdesc:acb5ef275ca019f2dcbe8c3ecdd51d237"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock corresponding to the root access unit.  <a href="#acb5ef275ca019f2dcbe8c3ecdd51d237">More...</a><br /></td></tr>
<tr class="separator:acb5ef275ca019f2dcbe8c3ecdd51d237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75e18cffb3264669783b5bb80c583c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1TreeManager.html#a4f75e18cffb3264669783b5bb80c583c">store_</a> {}</td></tr>
<tr class="memdesc:a4f75e18cffb3264669783b5bb80c583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The persistent store where the manager's tree is currently stored.  <a href="#a4f75e18cffb3264669783b5bb80c583c">More...</a><br /></td></tr>
<tr class="separator:a4f75e18cffb3264669783b5bb80c583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> class is a management and access entity for a program tree. </p>
<p>Each program or project in Envision is represented as a tree of nodes. To manage this tree each project has an associated <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> object.</p>
<p>The life cycle of a project begins with the creation of a new <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> object. This object can then be populated with program nodes by loading an existing tree from a persistent store or by creating a new tree structure.</p>
<p>Further access and operations on the tree are performed through the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> object. Here is a list of the functionality of a <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a>:</p><ul>
<li>Root node creation</li>
<li>Saving/loading a project to/from a persistent store</li>
<li>Access control to nodes in a concurrent setting</li>
<li>Undo/redo functionality</li>
<li>Notifications of project change </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad9c7505cbf864e392165cef60ed55719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::TreeManager::TreeManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> with the given <em>root</em>. </p>
<p>The undo history limit is set to 100 operations. </p>

</div>
</div>
<a class="anchor" id="aaa38bc53052362a7746b4258fb100b29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::TreeManager::TreeManager </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> with the given <em>name</em> and <em>root</em>. </p>
<p>The undo history limit is set to 100 operations. </p>

</div>
</div>
<a class="anchor" id="a8297bdb5d553898b62bd8971c91c3a46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Model::TreeManager::~TreeManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the root node corresponding to the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a>. </p>
<p>Deleting a node normally causes the corresponding subtree to be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a26ef85c4beb28c42d8df6523315d00d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::beginExclusiveRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins an exclusive read. </p>
<p>During an exclusive read, the tree can not be modified by any other thread. Other readers, including exclusive readers will be allowed to access the tree.</p>
<p>Call <a class="el" href="classModel_1_1TreeManager.html#a241b501086dd6bd821cad9033037819b" title="Ends an exclusive read. ">TreeManager::endExclusiveRead()</a> to end the exclusive reading block. </p>

</div>
</div>
<a class="anchor" id="a2aefa4b91245e7540bf1e79964368564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::beginModification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>modificationTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>QString()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a modification session. </p>
<p>Before calling a method on a tree node that modifies the node, a writer thread must first begin a modification session. Write access to the underlying tree must always occur in a modification block. Call <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a> to begin this block and <a class="el" href="classModel_1_1TreeManager.html#aac8a54eae11dc6186a44245cb7e28080" title="Ends a modification session. ">TreeManager::endModification()</a> to end the block:</p>
<p><a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> m; ... Node* someNode; ... m.beginModification(someNode, "modification description"); ... Code that makes modification to the subtree rooted at someNode, and within the access unit corresponding ... to someNode m.endModification(); ... Other exclusive readers or other writers can now be granted access</p>
<p>Only one thread can be in a modification session at a time. Furthermore this thread can only modify nodes which fall within the current access unit.</p>
<p>Each node has a unique access unit associated with it. An access unit is simply identified by a lock. The Node::getAccessLock() method can be used to get the access lock associated with a node. By default this is the lock of the parent node, or if there is no parent node (this is the root node), the lock of the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a>. The user can reimplement the Node::getAccessLock() method to return a new access lock therby defining a new access unit.</p>
<p>If there is a reader that has requested exclusive access via <a class="el" href="classModel_1_1TreeManager.html#a26ef85c4beb28c42d8df6523315d00d2" title="Begins an exclusive read. ">TreeManager::beginExclusiveRead()</a> this method will block until the reader calls <a class="el" href="classModel_1_1TreeManager.html#a241b501086dd6bd821cad9033037819b" title="Ends an exclusive read. ">TreeManager::endExclusiveRead()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modificationTarget</td><td>the top-most ancestor node of all nodes that will be modified.</td></tr>
    <tr><td class="paramname">text</td><td>the text that will be associated with this modification and put on the undo stack. This parameter has no effect if this modification is used to call undo/redo and not to execute new commands. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8ca7629df3ac48593ad1ac85fcdec48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::canBeModified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a node can be modified. </p>
<p>A node can be modified if the following three conditions are met:</p><ul>
<li>The manager is in a modification session, started with <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a>.</li>
<li>It is, or has as a parent, the current modification target.</li>
<li>It belongs to the same access unit as the current modification target.</li>
</ul>
<p>This method returns true if all conditions are met and false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d6a13b318d9f48d7e66da559281588f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::changeModificationTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>modificationTarget</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the modification target and possibly the access unit that the current writer is allowed to access. </p>
<p>This method can be used within a modification block in order to change the current modification target. This will release the access lock of the current target and acquire the lock of the new target.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modificationTarget</td><td>The target that should become the current modification target. The writer thread will be allowed to modify all nodes belonging to the subtree of this target and falling within the same access unit</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if this method is called without calling <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2fa702cc4143b16250f2dadab98d720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::emitNameModified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1NameText.html">NameText</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes a nameModified signal to be emitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that represents the name that has changed </td></tr>
    <tr><td class="paramname">oldName</td><td>What was the old name of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a241b501086dd6bd821cad9033037819b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::endExclusiveRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends an exclusive read. </p>
<p>This function must always be called after a call to <a class="el" href="classModel_1_1TreeManager.html#a26ef85c4beb28c42d8df6523315d00d2" title="Begins an exclusive read. ">TreeManager::beginExclusiveRead()</a> </p>

</div>
</div>
<a class="anchor" id="aac8a54eae11dc6186a44245cb7e28080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::endModification </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tryResolvingReferences</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends a modification session. </p>
<p>This method must always be called after a call <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a>. It concludes the modification session by releasing all acquired locks and emits the Mode::nodesModified signal to notify listeners about the changes.</p>
<p>This method must be called before the any other thread can gain exclusive access to the tree.</p>
<p>If <em>tryResolvingReferences</em> is true, then an attempt will be made to resolve all unresolved references. </p>

</div>
</div>
<a class="anchor" id="a822220c7500720cfb73cfc9fdac5aa4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::isBeingModified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20fdcc1210956ee86d8e5d1f315203c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::isOwnedByCommand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *&#160;</td>
          <td class="paramname"><em>excludeCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether <em>node</em> is transitively owned by <em>cmd</em>. </p>
<p>If <em>node</em> is only owned by <em>excludeCommand</em> this method returns false. </p>

</div>
</div>
<a class="anchor" id="af29d11d3109482a992a93f4c2f560d12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::isOwnedByUndoStack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1NodeOwningCommand.html">NodeOwningCommand</a> *&#160;</td>
          <td class="paramname"><em>excludeCommand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether <em>node</em> is owned by a command in the undo stack. </p>
<p>If <em>node</em> is only owned by <em>excludeCommand</em> this method returns false. </p>

</div>
</div>
<a class="anchor" id="a4433cdf4e9d40e637d4b09620a3861a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::isPartiallyLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this tree has been partially loaded (as a library). </p>

</div>
</div>
<a class="anchor" id="a8051861435f117ede32287ef207ad671"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loadPartially</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the manager's tree from the specified persistent store. </p>
<p>The provided store will become the current store of the manager.</p>
<p>If this manager already has a root node, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store where the manager's tree should be loaded from.</td></tr>
    <tr><td class="paramname">name</td><td>The tree name in the persistent store.</td></tr>
    <tr><td class="paramname">loadPartially</td><td>Whether the tree should only be partially loaded. The intention is that a partially loaded tree is read only and should only contain the publicly visible part of the tree. Typically this means excluding method bodies from loading. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a919ac640517add285e0d787775ebd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::TreeManager::modificationTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15ec062a1a6fa4ca0726542401ed8686"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::TreeManager::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the manged tree. </p>
<p>This is the name under which this tree can be found in the persistent store. </p>

</div>
</div>
<a class="anchor" id="ae8f5f25f8dbfee0da199d49e8694a8fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::nameModified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when the name of a node has changed. </p>
<p>This signal can be used to trigger symbolic reference updates, so that references are kept consistent when the name of a symbol changes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node that has a new name </td></tr>
    <tr><td class="paramname">oldName</td><td>The old name of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2994d61f89240710371f946644303d84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a> &amp; Model::TreeManager::nodeIdMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac95267d50f9f44805cda70179716e841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a> &amp; Model::TreeManager::nodeIdMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a003d80057998b83de176806c599bf24c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::nodesModified </td>
          <td>(</td>
          <td class="paramtype">QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>modifiedNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td>
          <td class="paramname"><em>removedNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted at the end of a modification block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modifiedNodes</td><td>A set of all nodes modified within this block. These nodes might include nodes in <em>removedNodes</em> </td></tr>
    <tr><td class="paramname">removedNodes</td><td>A set of all nodes that have been removed within this block. These nodes might include nodes in <em>modifiedNodes</em>. The set of reported nodes is all nodes that have been removed, including children of removed nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0119abce74eff60b2a22f5367cfad64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::notifyNodeChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <em>node</em> to the list of modified nodes during an edit operation or immediately emits a nodesModified signal with the specified node if no modification to the tree is ongoing. </p>
<p>For usual edit operations that alter the tree, you do not need to explicitly call this method. It is useful for cases where only a caching property of a node has changed which might lead to changes in its visualization.</p>
<p>For example this method can be used when resolving references to notify visualizations of changes to the reference targets. </p>

</div>
</div>
<a class="anchor" id="a1a383b92bde574517f1b93da8dd5fb82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::pushCommandOnUndoStack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes the specified command on the undo stack and executes it. </p>
<p>This method can only be called inside a modification block initiated with <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a>. Furthermore no calls to <a class="el" href="classModel_1_1TreeManager.html#a042d082dc20453f6cdb0c3b6ccb6e78b" title="Undoes the commands executed in the previous modification block. ">TreeManager::undo</a> or <a class="el" href="classModel_1_1TreeManager.html#adc63a3c45ca251664a2f52e17c4f74d4" title="Redoes the commands executed in the next modification block. ">TreeManager::redo</a> can be made in the current modification block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to add to the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a> first or if calls to <a class="el" href="classModel_1_1TreeManager.html#a042d082dc20453f6cdb0c3b6ccb6e78b" title="Undoes the commands executed in the previous modification block. ">TreeManager::undo()</a> or <a class="el" href="classModel_1_1TreeManager.html#adc63a3c45ca251664a2f52e17c4f74d4" title="Redoes the commands executed in the next modification block. ">TreeManager::redo()</a> have already been made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc63a3c45ca251664a2f52e17c4f74d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::redo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redoes the commands executed in the next modification block. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling <a class="el" href="classModel_1_1TreeManager.html#a2aefa4b91245e7540bf1e79964368564" title="Begins a modification session. ">TreeManager::beginModification()</a> first or if a call to <a class="el" href="classModel_1_1TreeManager.html#a1a383b92bde574517f1b93da8dd5fb82" title="Pushes the specified command on the undo stack and executes it. ">TreeManager::pushCommandOnUndoStack()</a> has already been made within this modification block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cbf0d71e7c5e1193fab5e61fb8bda95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::TreeManager::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root node for this manager. </p>

</div>
</div>
<a class="anchor" id="a89ca22fb514d3cb055a395c2ae94c240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> * Model::TreeManager::rootLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lock corresponding to the top-most (root) access unit. </p>

</div>
</div>
<a class="anchor" id="a91af5b04ec2b94f3cfeb4f7ec93c8a70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::rootNodeSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">signal</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emitted when a new root node was set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>A pointer to the new root node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99a30036999ba5f1e38a9cb54ec4e4f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> *&#160;</td>
          <td class="paramname"><em>store</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the tree in persistent store of the tree manager. </p>
<p>If this manager does not have a current store, the store argument must not be NULL. In that case the provided store will become the current store of the manager.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store where the tree should be saved. If this is NULL the current store will be used. The current store is the one from which the tree was loaded. If this is not NULL it will be used instead of the current store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4aa1bb4b3d0115ca75b3ff33e3730a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::setName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name of the tree. </p>
<p>This is the name under which this tree will be save in the persistent store. </p>

</div>
</div>
<a class="anchor" id="a3f4d2090df88eb35010b7ebbc8e1b9b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::setRoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the root node of this manager to <em>node</em>. </p>
<p>The <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> should not have a root node set. This method must be called outside of a modification block. This action can not be undone. </p>

</div>
</div>
<a class="anchor" id="a464ebd9d99f9664c744fb6f1de356df0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> * Model::TreeManager::store </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current store for this manager. </p>
<p>The current store is the store used to load the manager's tree. If the tree was created rather than loaded and has not been saved to a persistent store yet this method will return NULL. </p>

</div>
</div>
<a class="anchor" id="a042d082dc20453f6cdb0c3b6ccb6e78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::TreeManager::undo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undoes the commands executed in the previous modification block. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classModel_1_1ModelException.html">ModelException</a></td><td>if called without calling Model::beginModification() first or if a call to Model::pushCommandOnUndoStack() has already been made within this modification block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abb0470001a39781fc3338ce0338a1767"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QUndoStack Model::TreeManager::commands</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The command stack that holds the undo history. </p>

</div>
</div>
<a class="anchor" id="a1cd56c7199c8a26c9440c071741539be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a>* Model::TreeManager::currentModificationLock {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lock of the access unit that is responsible for the current modification target node. </p>
<p>Each node has exactly one access unit corresponding to it. A writer must acquire this lock before any modification can occur. The currently acquired lock is stored here so that each write operation can be checked to assure that no write occurs outside of the access unit. </p>

</div>
</div>
<a class="anchor" id="a2440be1f418c2b5874aefcc6754dfeca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* Model::TreeManager::currentModificationTarget {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The node that is the top-most ancestor of all other nodes that are currently being modification. </p>
<p>Only nodes in the same access unit and below this node (including the node itself) may be modified. </p>

</div>
</div>
<a class="anchor" id="a97ec8f9a421c5d79e978dde586e1ed7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QReadWriteLock Model::TreeManager::exclusiveAccess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A ReadWrite lock used for exclusive writer or reader access. </p>
<p>Writers always acquire this lock first and then proceed to acquire exactly one other lock corresponding to the access unit they want to write to.</p>
<p>A reader that requires exclusive access (other readers can still read, but writers can not) can also acquire this lock. Typically however readers do not acquire this lock. </p>

</div>
</div>
<a class="anchor" id="a6487047f413f10030f40da709814e8c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::modificationInProgress {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This flag indicates if a modification is currently in progress. </p>
<p>Commands can be pushed on the undo stack and executed only if this is true. </p>

</div>
</div>
<a class="anchor" id="a85fee1c9bb0d3da43999996fa6760150"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::TreeManager::modificationText</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The test message associated with the current modification operation. </p>
<p>This text is only used to describe the undo operation that is currently performed. </p>

</div>
</div>
<a class="anchor" id="a5b15b5d2cc58cadc8a76caf9658c41e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt;<a class="el" href="classModel_1_1Node.html">Node</a>*&gt; Model::TreeManager::modifiedTargets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A set of all nodes which might have been modified as part of the last modification operation. </p>
<p>This is only used to signal to anyone who is interested in monitoring changes. </p>

</div>
</div>
<a class="anchor" id="aaf58027de7c27192d76d1d73185793e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::TreeManager::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of this manager's tree. </p>
<p>This name will be used to save the tree in the persistent store. </p>

</div>
</div>
<a class="anchor" id="aed69cb047e6e7bd7f5672b677c5eb467"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeIdMap.html">NodeIdMap</a> Model::TreeManager::nodeIdMap_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0738c02e6862297717b30650ea16f75d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::partiallyLoaded_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this tree has been partially loaded (as a library) from a store. </p>

</div>
</div>
<a class="anchor" id="a4b00a79b2d5dfb1cea5a5552d6383019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::performedUndoRedo {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if <a class="el" href="classModel_1_1TreeManager.html#a042d082dc20453f6cdb0c3b6ccb6e78b" title="Undoes the commands executed in the previous modification block. ">undo()</a> or <a class="el" href="classModel_1_1TreeManager.html#adc63a3c45ca251664a2f52e17c4f74d4" title="Redoes the commands executed in the next modification block. ">redo()</a> were called during the last modification operation. </p>
<p>A modification operation can do two things:</p><ul>
<li>Add new commands on the stack</li>
<li>Call undo/redo</li>
</ul>
<p>The two can not be mixed in the same operation and this flag is used to control this. </p>

</div>
</div>
<a class="anchor" id="ae35082120b91fffc79bd063d5760c28a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::TreeManager::pushedNewCommandsOnTheStack {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if the last modification operation pushed commands on stack. </p>
<p>A modification operation can do two things:</p><ul>
<li>Add new commands on the stack</li>
<li>Call undo/redo</li>
</ul>
<p>The two can not be mixed in the same operation and this flag is used to control this. </p>

</div>
</div>
<a class="anchor" id="a1962b73fc09638dcd7d958fc387847c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt;<a class="el" href="classModel_1_1Node.html">Node</a>*&gt; Model::TreeManager::removedTargets_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A set of all nodes which have been removed from the tree as part of the last modification operation. </p>
<p>This is only used to signal to anyone who is interested in monitoring changes. </p>

</div>
</div>
<a class="anchor" id="a0d96ba6032a8e12941ba266dd3f4ef97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* Model::TreeManager::root_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The root node for this manager's tree. </p>

</div>
</div>
<a class="anchor" id="acb5ef275ca019f2dcbe8c3ecdd51d237"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> Model::TreeManager::rootLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lock corresponding to the root access unit. </p>
<p>This is used by synchronized readers and by writers to control access to the root unit. </p>

</div>
</div>
<a class="anchor" id="a4f75e18cffb3264669783b5bb80c583c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a>* Model::TreeManager::store_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The persistent store where the manager's tree is currently stored. </p>
<p>This is used in calls to Node::loadFully when a partially loaded node needs to load its entire contents. It can also be used by other stores when the tree needs to be saved to a different location. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
