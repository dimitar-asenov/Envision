<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Envision: Model::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Envision
   </div>
   <div id="projectbrief">A visual programming IDE for object-oriented languages</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceModel.html">Model</a></li><li class="navelem"><a class="el" href="classModel_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classModel_1_1Node-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Model::Node Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> class is the foundation element in the tree in Envision.  
 <a href="classModel_1_1Node.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0e2e9bad8ff0ccde3c945aa359f81a79"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79">FindSymbolDirection</a> { <a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79a442bce153404d787512d1392ba9000fa">SEARCH_UP</a>, 
<a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79ad32cc9e783e89ba6ffb83011a55abe97">SEARCH_DOWN</a>, 
<a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79ac0232fa9373d329c1b413b8058db0209">SEARCH_HERE</a>
 }</td></tr>
<tr class="separator:a0e2e9bad8ff0ccde3c945aa359f81a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d3a7201bf31b72f1be907e7182484e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classModel_1_1Node.html">Node</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a29d3a7201bf31b72f1be907e7182484e">NodeConstructor</a>) (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td></tr>
<tr class="memdesc:a29d3a7201bf31b72f1be907e7182484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer type is used to register a constructor for nodes.  <a href="#a29d3a7201bf31b72f1be907e7182484e">More...</a><br /></td></tr>
<tr class="separator:a29d3a7201bf31b72f1be907e7182484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eed04b65436277c4e970b6c20827b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classModel_1_1Node.html">Node</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ac1eed04b65436277c4e970b6c20827b0">NodePersistenceConstructor</a>) (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td></tr>
<tr class="memdesc:ac1eed04b65436277c4e970b6c20827b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function pointer type is used to register the constructor for nodes that are being loaded from a persistent store.  <a href="#ac1eed04b65436277c4e970b6c20827b0">More...</a><br /></td></tr>
<tr class="separator:ac1eed04b65436277c4e970b6c20827b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9aeda176a34521dc812ecf7a3d4626"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626">SymbolType</a> { <a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626a64654d684ce9e1b176602e431e8f4ede">UNSPECIFIED</a> = 0x0, 
<a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626a02e84a1c4f978e55c8b4bd8881046a3c">METHOD</a> = 0x1, 
<a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626a31efe4c19e97f4901216833fcfa1624a">CONTAINER</a> = 0x2, 
<a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626acb4740282468669ce6845a9ef6fbb8e7">VARIABLE</a> = 0x4, 
<a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626a8ecd03bd1aae995d469430e3d033c5ba">ANY_SYMBOL</a> = 0xffffffff
 }</td></tr>
<tr class="separator:ade9aeda176a34521dc812ecf7a3d4626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6026745a457fb0edde390e06c8168391"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6026745a457fb0edde390e06c8168391">Node</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>=nullptr)</td></tr>
<tr class="memdesc:a6026745a457fb0edde390e06c8168391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new node with the specified parent.  <a href="#a6026745a457fb0edde390e06c8168391">More...</a><br /></td></tr>
<tr class="separator:a6026745a457fb0edde390e06c8168391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0c3ccbae8a426091c6a1679f16e730"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6a0c3ccbae8a426091c6a1679f16e730">Node</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> &amp;other)</td></tr>
<tr class="memdesc:a6a0c3ccbae8a426091c6a1679f16e730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6a0c3ccbae8a426091c6a1679f16e730">More...</a><br /></td></tr>
<tr class="separator:a6a0c3ccbae8a426091c6a1679f16e730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93b813886967b6d93a351c75f31b6e5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab93b813886967b6d93a351c75f31b6e5">~Node</a> ()</td></tr>
<tr class="separator:ab93b813886967b6d93a351c75f31b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33e411bb1aa1aabca6d162f66bc481f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa33e411bb1aa1aabca6d162f66bc481f">accessLock</a> () const </td></tr>
<tr class="memdesc:aa33e411bb1aa1aabca6d162f66bc481f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lock used to control access to this node.  <a href="#aa33e411bb1aa1aabca6d162f66bc481f">More...</a><br /></td></tr>
<tr class="separator:aa33e411bb1aa1aabca6d162f66bc481f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c0d0ffbf6398cc48fd6627ddab6cfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a72c0d0ffbf6398cc48fd6627ddab6cfe">addToRevision</a> (int valueToAdd)</td></tr>
<tr class="memdesc:a72c0d0ffbf6398cc48fd6627ddab6cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the revision of this node by the specified amount.  <a href="#a72c0d0ffbf6398cc48fd6627ddab6cfe">More...</a><br /></td></tr>
<tr class="separator:a72c0d0ffbf6398cc48fd6627ddab6cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c6fa88579de718cfc16e2a5c22e8e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ae6c6fa88579de718cfc16e2a5c22e8e3">beginModification</a> (const QString &amp;text=QString())</td></tr>
<tr class="memdesc:ae6c6fa88579de718cfc16e2a5c22e8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a modification session with the current node as a modification target.  <a href="#ae6c6fa88579de718cfc16e2a5c22e8e3">More...</a><br /></td></tr>
<tr class="separator:ae6c6fa88579de718cfc16e2a5c22e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c5add36bb451a75764b01b6cd15680"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa8c5add36bb451a75764b01b6cd15680">children</a> () const </td></tr>
<tr class="memdesc:aa8c5add36bb451a75764b01b6cd15680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all child nodes.  <a href="#aa8c5add36bb451a75764b01b6cd15680">More...</a><br /></td></tr>
<tr class="separator:aa8c5add36bb451a75764b01b6cd15680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427c24fa5263d22e93b22f6060539843"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a427c24fa5263d22e93b22f6060539843">childrenInScope</a> () const </td></tr>
<tr class="memdesc:a427c24fa5263d22e93b22f6060539843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all child nodes that may define symbols that form the scope of this node.  <a href="#a427c24fa5263d22e93b22f6060539843">More...</a><br /></td></tr>
<tr class="separator:a427c24fa5263d22e93b22f6060539843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58662c38c52044cc2af67744d310f8cd"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a58662c38c52044cc2af67744d310f8cd"><td class="memTemplItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a58662c38c52044cc2af67744d310f8cd">childrenWhich</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *from, Predicate p)</td></tr>
<tr class="separator:a58662c38c52044cc2af67744d310f8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c86ab8359212f69dcbafd1f40bd8aea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6c86ab8359212f69dcbafd1f40bd8aea">childToSubnode</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *other) const </td></tr>
<tr class="memdesc:a6c86ab8359212f69dcbafd1f40bd8aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the direct child node that is equal to <em>other</em> or is an ancestor of <em>other</em>.  <a href="#a6c86ab8359212f69dcbafd1f40bd8aea">More...</a><br /></td></tr>
<tr class="separator:a6c86ab8359212f69dcbafd1f40bd8aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d51c241cde5c82888b5e438ef02344"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a31d51c241cde5c82888b5e438ef02344">clone</a> () const =0</td></tr>
<tr class="separator:a31d51c241cde5c82888b5e438ef02344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc19699b25363ba3474acf0000da4329"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329">definesSymbol</a> () const </td></tr>
<tr class="memdesc:acc19699b25363ba3474acf0000da4329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node defines a symbol and false otherwise.  <a href="#acc19699b25363ba3474acf0000da4329">More...</a><br /></td></tr>
<tr class="separator:acc19699b25363ba3474acf0000da4329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54d77f21d23364b560deeca22a6347e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ad54d77f21d23364b560deeca22a6347e">endModification</a> ()</td></tr>
<tr class="memdesc:ad54d77f21d23364b560deeca22a6347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends a modification session.  <a href="#ad54d77f21d23364b560deeca22a6347e">More...</a><br /></td></tr>
<tr class="separator:ad54d77f21d23364b560deeca22a6347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aad10e0ec7b9359f325db5a3c4fbf90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a9aad10e0ec7b9359f325db5a3c4fbf90">execute</a> (<a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *command)</td></tr>
<tr class="memdesc:a9aad10e0ec7b9359f325db5a3c4fbf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the specified command and pushes it on the undo stack.  <a href="#a9aad10e0ec7b9359f325db5a3c4fbf90">More...</a><br /></td></tr>
<tr class="separator:a9aad10e0ec7b9359f325db5a3c4fbf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5949daf00c16bd91d7a5b64441f0fd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa5949daf00c16bd91d7a5b64441f0fd4">findSymbols</a> (QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; &amp;result, const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;matcher, const <a class="el" href="classModel_1_1Node.html">Node</a> *source, <a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79">FindSymbolDirection</a> direction, SymbolTypes symbolTypes, bool exhaustAllScopes) const </td></tr>
<tr class="memdesc:aa5949daf00c16bd91d7a5b64441f0fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <em>result</em> a set of all nodes which define a symbol with a name matching <em>matcher</em> in the scope of this node.  <a href="#aa5949daf00c16bd91d7a5b64441f0fd4">More...</a><br /></td></tr>
<tr class="separator:aa5949daf00c16bd91d7a5b64441f0fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab783131a246c62272ec2e89fb812834b"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:ab783131a246c62272ec2e89fb812834b"><td class="memTemplItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab783131a246c62272ec2e89fb812834b">firstAncestorOfType</a> ()</td></tr>
<tr class="memdesc:ab783131a246c62272ec2e89fb812834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first Ancestor which has the type <em>NodeType</em> if there is one, otherwise null.  <a href="#ab783131a246c62272ec2e89fb812834b">More...</a><br /></td></tr>
<tr class="separator:ab783131a246c62272ec2e89fb812834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf82e31f88ef1b7b899995a8e4510fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#acf82e31f88ef1b7b899995a8e4510fb2">firstAncestorOfType</a> (const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;typeMatch) const </td></tr>
<tr class="memdesc:acf82e31f88ef1b7b899995a8e4510fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first Ancestor for which typeName() matches with <em>typeMatch</em>, if there is one, otherwise null.  <a href="#acf82e31f88ef1b7b899995a8e4510fb2">More...</a><br /></td></tr>
<tr class="separator:acf82e31f88ef1b7b899995a8e4510fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e6b348411ba66c33eb93fb855aeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6b7e6b348411ba66c33eb93fb855aeb0">hasPartiallyLoadedChildren</a> () const </td></tr>
<tr class="memdesc:a6b7e6b348411ba66c33eb93fb855aeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is partially loaded or has partially loaded children.  <a href="#a6b7e6b348411ba66c33eb93fb855aeb0">More...</a><br /></td></tr>
<tr class="separator:a6b7e6b348411ba66c33eb93fb855aeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410cafa4e196e8f572d6f24992bfc914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a410cafa4e196e8f572d6f24992bfc914">incrementRevision</a> ()</td></tr>
<tr class="memdesc:a410cafa4e196e8f572d6f24992bfc914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the revision of this node by 1.  <a href="#a410cafa4e196e8f572d6f24992bfc914">More...</a><br /></td></tr>
<tr class="separator:a410cafa4e196e8f572d6f24992bfc914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdb27f1c721bd3d89c7881dabd7efc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a9fdb27f1c721bd3d89c7881dabd7efc9">isAncestorOf</a> (const <a class="el" href="classModel_1_1Node.html">Node</a> *other) const </td></tr>
<tr class="memdesc:a9fdb27f1c721bd3d89c7881dabd7efc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of this node is an Ancestor of other and false otherwise.  <a href="#a9fdb27f1c721bd3d89c7881dabd7efc9">More...</a><br /></td></tr>
<tr class="separator:a9fdb27f1c721bd3d89c7881dabd7efc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e99d1b37afb4ca5575d68391cc0455"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a78e99d1b37afb4ca5575d68391cc0455">isModifyable</a> () const </td></tr>
<tr class="memdesc:a78e99d1b37afb4ca5575d68391cc0455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true is the this node can be modified or false otherwise.  <a href="#a78e99d1b37afb4ca5575d68391cc0455">More...</a><br /></td></tr>
<tr class="separator:a78e99d1b37afb4ca5575d68391cc0455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc47bd4c6dcda029cbcc91a12315e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3acc47bd4c6dcda029cbcc91a12315e1">isNewPersistenceUnit</a> () const </td></tr>
<tr class="memdesc:a3acc47bd4c6dcda029cbcc91a12315e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node should be persisted in a new persistence unit.  <a href="#a3acc47bd4c6dcda029cbcc91a12315e1">More...</a><br /></td></tr>
<tr class="separator:a3acc47bd4c6dcda029cbcc91a12315e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480f996764f0f65c60d2fdeff3d7a91d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a480f996764f0f65c60d2fdeff3d7a91d">isPartiallyLoaded</a> () const </td></tr>
<tr class="memdesc:a480f996764f0f65c60d2fdeff3d7a91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is only partially loaded.  <a href="#a480f996764f0f65c60d2fdeff3d7a91d">More...</a><br /></td></tr>
<tr class="separator:a480f996764f0f65c60d2fdeff3d7a91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbd7d3b65eaa81a451389a9db3aaa3b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a5dbd7d3b65eaa81a451389a9db3aaa3b">isTransparentForNameResolution</a> () const </td></tr>
<tr class="memdesc:a5dbd7d3b65eaa81a451389a9db3aaa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node should propagate name resolution requests through it, as if were not there.  <a href="#a5dbd7d3b65eaa81a451389a9db3aaa3b">More...</a><br /></td></tr>
<tr class="separator:a5dbd7d3b65eaa81a451389a9db3aaa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20246c48b754e0fceeb7c921f2f1f57b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a20246c48b754e0fceeb7c921f2f1f57b">load</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store)=0</td></tr>
<tr class="memdesc:a20246c48b754e0fceeb7c921f2f1f57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads this node from a persistent store.  <a href="#a20246c48b754e0fceeb7c921f2f1f57b">More...</a><br /></td></tr>
<tr class="separator:a20246c48b754e0fceeb7c921f2f1f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e3b8c2c318384183aa27971e3ac59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ae5e3b8c2c318384183aa27971e3ac59f">lowestCommonAncestor</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *other, <a class="el" href="classModel_1_1Node.html">Node</a> **thisParent=nullptr, <a class="el" href="classModel_1_1Node.html">Node</a> **otherParent=nullptr)</td></tr>
<tr class="memdesc:ae5e3b8c2c318384183aa27971e3ac59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lowest common ancestor of this node and other.  <a href="#ae5e3b8c2c318384183aa27971e3ac59f">More...</a><br /></td></tr>
<tr class="separator:ae5e3b8c2c318384183aa27971e3ac59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ec6807ca4e9e48845bfd44ca946195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ab0ec6807ca4e9e48845bfd44ca946195">manager</a> () const </td></tr>
<tr class="memdesc:ab0ec6807ca4e9e48845bfd44ca946195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tree manager of the current <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>.  <a href="#ab0ec6807ca4e9e48845bfd44ca946195">More...</a><br /></td></tr>
<tr class="separator:ab0ec6807ca4e9e48845bfd44ca946195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0027c2328323a4733b3e594958b6998a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a> () const </td></tr>
<tr class="memdesc:a0027c2328323a4733b3e594958b6998a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> or NULL if this is the root.  <a href="#a0027c2328323a4733b3e594958b6998a">More...</a><br /></td></tr>
<tr class="separator:a0027c2328323a4733b3e594958b6998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b8c8cba2f1ec245a6565436b40693b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a38b8c8cba2f1ec245a6565436b40693b">persistentUnitNode</a> () const </td></tr>
<tr class="memdesc:a38b8c8cba2f1ec245a6565436b40693b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node that defines the persistence unit for this node.  <a href="#a38b8c8cba2f1ec245a6565436b40693b">More...</a><br /></td></tr>
<tr class="separator:a38b8c8cba2f1ec245a6565436b40693b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f7e4d0475077b671b7ee108e937593"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a98f7e4d0475077b671b7ee108e937593">replaceChild</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *child, <a class="el" href="classModel_1_1Node.html">Node</a> *replacement)</td></tr>
<tr class="memdesc:a98f7e4d0475077b671b7ee108e937593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the child item <em>child</em> with the item <em>replacement</em> and returns true on success.  <a href="#a98f7e4d0475077b671b7ee108e937593">More...</a><br /></td></tr>
<tr class="separator:a98f7e4d0475077b671b7ee108e937593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e082304e233d32dde632280c99241"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a868e082304e233d32dde632280c99241">revision</a> () const </td></tr>
<tr class="memdesc:a868e082304e233d32dde632280c99241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the revision of this node.  <a href="#a868e082304e233d32dde632280c99241">More...</a><br /></td></tr>
<tr class="separator:a868e082304e233d32dde632280c99241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ce4ee82d2c0ed0b211fa29aec22923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a78ce4ee82d2c0ed0b211fa29aec22923">root</a> () const </td></tr>
<tr class="memdesc:a78ce4ee82d2c0ed0b211fa29aec22923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of tree where of this node.  <a href="#a78ce4ee82d2c0ed0b211fa29aec22923">More...</a><br /></td></tr>
<tr class="separator:a78ce4ee82d2c0ed0b211fa29aec22923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d34fac51548633d6748b09f47a3d92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a30d34fac51548633d6748b09f47a3d92">save</a> (<a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store) const =0</td></tr>
<tr class="memdesc:a30d34fac51548633d6748b09f47a3d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current node to a persistent store.  <a href="#a30d34fac51548633d6748b09f47a3d92">More...</a><br /></td></tr>
<tr class="separator:a30d34fac51548633d6748b09f47a3d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0662a376982b4cce855e731a0d8134a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0662a376982b4cce855e731a0d8134a8">setParent</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td></tr>
<tr class="memdesc:a0662a376982b4cce855e731a0d8134a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>.  <a href="#a0662a376982b4cce855e731a0d8134a8">More...</a><br /></td></tr>
<tr class="separator:a0662a376982b4cce855e731a0d8134a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b3b92f33676eef70c7c7ce525ad97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa5b3b92f33676eef70c7c7ce525ad97f">setRootManager</a> (<a class="el" href="classModel_1_1TreeManager.html">TreeManager</a> *<a class="el" href="classModel_1_1Node.html#ab0ec6807ca4e9e48845bfd44ca946195">manager</a>)</td></tr>
<tr class="memdesc:aa5b3b92f33676eef70c7c7ce525ad97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the manager of this root node to <em>manager</em>.  <a href="#aa5b3b92f33676eef70c7c7ce525ad97f">More...</a><br /></td></tr>
<tr class="separator:aa5b3b92f33676eef70c7c7ce525ad97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02456394b3aa6526a11ff61cd4e6fcfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a02456394b3aa6526a11ff61cd4e6fcfe">symbolMatches</a> (const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;matcher, SymbolTypes symbolTypes) const </td></tr>
<tr class="memdesc:a02456394b3aa6526a11ff61cd4e6fcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node defines a symbol that has a name matching <em>matcher</em> and types common with <em>symbolTypes</em>.  <a href="#a02456394b3aa6526a11ff61cd4e6fcfe">More...</a><br /></td></tr>
<tr class="separator:a02456394b3aa6526a11ff61cd4e6fcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0238f80b3ad5960919e56e959fb8b36"><td class="memItemLeft" align="right" valign="top">virtual const QString &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36">symbolName</a> () const </td></tr>
<tr class="memdesc:ac0238f80b3ad5960919e56e959fb8b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the symbol defined by this node.  <a href="#ac0238f80b3ad5960919e56e959fb8b36">More...</a><br /></td></tr>
<tr class="separator:ac0238f80b3ad5960919e56e959fb8b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c22e6f01f3728581705da5298af16"><td class="memItemLeft" align="right" valign="top">virtual SymbolTypes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a8e7c22e6f01f3728581705da5298af16">symbolType</a> () const </td></tr>
<tr class="memdesc:a8e7c22e6f01f3728581705da5298af16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the symbol defined by this node.  <a href="#a8e7c22e6f01f3728581705da5298af16">More...</a><br /></td></tr>
<tr class="separator:a8e7c22e6f01f3728581705da5298af16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283efe5bf4f53d649a1ae1b1adf3dc0d"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a283efe5bf4f53d649a1ae1b1adf3dc0d">toDebugString</a> ()</td></tr>
<tr class="memdesc:a283efe5bf4f53d649a1ae1b1adf3dc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this node to a string for use in debug purposes only.  <a href="#a283efe5bf4f53d649a1ae1b1adf3dc0d">More...</a><br /></td></tr>
<tr class="separator:a283efe5bf4f53d649a1ae1b1adf3dc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceaa207bf87136fe98fe490a063b144"><td class="memItemLeft" align="right" valign="top">virtual QList&lt; const <a class="el" href="classModel_1_1UsedLibrary.html">UsedLibrary</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#afceaa207bf87136fe98fe490a063b144">usedLibraries</a> () const </td></tr>
<tr class="memdesc:afceaa207bf87136fe98fe490a063b144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all libraries that are used by this node and its subnodes.  <a href="#afceaa207bf87136fe98fe490a063b144">More...</a><br /></td></tr>
<tr class="separator:afceaa207bf87136fe98fe490a063b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3c2cc03d20d8332566a10a832bdef8e6"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:a3c2cc03d20d8332566a10a832bdef8e6"><td class="memTemplItemLeft" align="right" valign="top">static QList&lt; NodeType * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a3c2cc03d20d8332566a10a832bdef8e6">childrenOfType</a> (<a class="el" href="classModel_1_1Node.html">Model::Node</a> *from)</td></tr>
<tr class="memdesc:a3c2cc03d20d8332566a10a832bdef8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all children including the node <em>from</em>, which have type <em>NodeType</em>.  <a href="#a3c2cc03d20d8332566a10a832bdef8e6">More...</a><br /></td></tr>
<tr class="separator:a3c2cc03d20d8332566a10a832bdef8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e9a04f8ca9bb1de7396e12c2803fd2"><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr class="memitem:a36e9a04f8ca9bb1de7396e12c2803fd2"><td class="memTemplItemLeft" align="right" valign="top">static QList&lt; <a class="el" href="classModel_1_1Node.html">Model::Node</a> * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a36e9a04f8ca9bb1de7396e12c2803fd2">childrenWhich</a> (<a class="el" href="classModel_1_1Node.html">Model::Node</a> *from, Predicate p)</td></tr>
<tr class="memdesc:a36e9a04f8ca9bb1de7396e12c2803fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all children including the node <em>from</em>, which fullfill the <em>Predicate</em> <em>p</em>, i.e.  <a href="#a36e9a04f8ca9bb1de7396e12c2803fd2">More...</a><br /></td></tr>
<tr class="separator:a36e9a04f8ca9bb1de7396e12c2803fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da5da50350c88318893b891940ccf60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a6da5da50350c88318893b891940ccf60">createDefaultInstance</a> (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td></tr>
<tr class="memdesc:a6da5da50350c88318893b891940ccf60"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> is an abstract class this method always returns nullptr.  <a href="#a6da5da50350c88318893b891940ccf60">More...</a><br /></td></tr>
<tr class="separator:a6da5da50350c88318893b891940ccf60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca79f2a20d8993eea0e86ca6088da7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a0ca79f2a20d8993eea0e86ca6088da7c">createNewNode</a> (const QString &amp;type, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>=nullptr)</td></tr>
<tr class="memdesc:a0ca79f2a20d8993eea0e86ca6088da7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node of the specified type.  <a href="#a0ca79f2a20d8993eea0e86ca6088da7c">More...</a><br /></td></tr>
<tr class="separator:a0ca79f2a20d8993eea0e86ca6088da7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d7cfdf3abf4c1c2bbefc3654678805"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a12d7cfdf3abf4c1c2bbefc3654678805">createNewNode</a> (const QString &amp;type, <a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td></tr>
<tr class="memdesc:a12d7cfdf3abf4c1c2bbefc3654678805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new node of the specified type by loading it from a persistent store.  <a href="#a12d7cfdf3abf4c1c2bbefc3654678805">More...</a><br /></td></tr>
<tr class="separator:a12d7cfdf3abf4c1c2bbefc3654678805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce3db1f4cf4cf5192694631148aebcb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#abce3db1f4cf4cf5192694631148aebcb">isTypeRegistered</a> (const QString &amp;type)</td></tr>
<tr class="memdesc:abce3db1f4cf4cf5192694631148aebcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are already registered constructs for a type with the specified name and false otherwise.  <a href="#abce3db1f4cf4cf5192694631148aebcb">More...</a><br /></td></tr>
<tr class="separator:abce3db1f4cf4cf5192694631148aebcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae241d587f6660096695f8e714e5008fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ae241d587f6660096695f8e714e5008fd">registerNodeType</a> (const QString &amp;type, const <a class="el" href="classModel_1_1Node.html#a29d3a7201bf31b72f1be907e7182484e">NodeConstructor</a> constructor, const <a class="el" href="classModel_1_1Node.html#ac1eed04b65436277c4e970b6c20827b0">NodePersistenceConstructor</a> persistenceconstructor)</td></tr>
<tr class="memdesc:ae241d587f6660096695f8e714e5008fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the constructors of a class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>.  <a href="#ae241d587f6660096695f8e714e5008fd">More...</a><br /></td></tr>
<tr class="separator:ae241d587f6660096695f8e714e5008fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa057da12df8ca1b205e4556a5e1ec655"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aa057da12df8ca1b205e4556a5e1ec655">setPartiallyLoaded</a> ()</td></tr>
<tr class="separator:aa057da12df8ca1b205e4556a5e1ec655"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4b556959f8eb58b5e0ad2c154700e810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a4b556959f8eb58b5e0ad2c154700e810">propagateManagerToChildren</a> ()</td></tr>
<tr class="separator:a4b556959f8eb58b5e0ad2c154700e810"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ace3a8ec46cff8d318fc2da397b710862"><td class="memItemLeft" align="right" valign="top">static QSet&lt; const <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ace3a8ec46cff8d318fc2da397b710862">partiallyLoadedNodes</a> ()</td></tr>
<tr class="separator:ace3a8ec46cff8d318fc2da397b710862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a617cdb5ee1a5c38e2a29716b4a84b15e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a617cdb5ee1a5c38e2a29716b4a84b15e">manager_</a> {}</td></tr>
<tr class="separator:a617cdb5ee1a5c38e2a29716b4a84b15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6f51536abb137ede5c427725222d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#ad3a6f51536abb137ede5c427725222d3">parent_</a> {}</td></tr>
<tr class="separator:ad3a6f51536abb137ede5c427725222d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cec2acbdfb8620d4901ada5600faacd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a7cec2acbdfb8620d4901ada5600faacd">revision_</a> {}</td></tr>
<tr class="separator:a7cec2acbdfb8620d4901ada5600faacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aaa9eb8e52cbbb0369643a683ac9d5ce0"><td class="memItemLeft" align="right" valign="top">static QHash&lt; QString, <a class="el" href="classModel_1_1Node.html#a29d3a7201bf31b72f1be907e7182484e">NodeConstructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#aaa9eb8e52cbbb0369643a683ac9d5ce0">nodeConstructorRegister</a></td></tr>
<tr class="separator:aaa9eb8e52cbbb0369643a683ac9d5ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccb5dd46db0cc4e08f1aea6b982b6d2"><td class="memItemLeft" align="right" valign="top">static QHash&lt; QString, <a class="el" href="classModel_1_1Node.html#ac1eed04b65436277c4e970b6c20827b0">NodePersistenceConstructor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classModel_1_1Node.html#a1ccb5dd46db0cc4e08f1aea6b982b6d2">nodePersistenceConstructorRegister</a></td></tr>
<tr class="separator:a1ccb5dd46db0cc4e08f1aea6b982b6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> class is the foundation element in the tree in Envision. </p>
<p>An application in Envision is a collection of objects of type <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> (and derived) that are managed by a single <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> object. Nodes are combined together in a tree structure. This class defines the minimal interface of each node and implements some service functions.</p>
<p>Each class that derives from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> must have at least two constructors which need to be registered before that class can be used. This is achieved using the static method '<a class="el" href="classModel_1_1Node.html#ae241d587f6660096695f8e714e5008fd" title="Registers the constructors of a class derived from Node. ">registerNodeType()</a>'.</p>
<p>Derived classes must implement the '<a class="el" href="classModel_1_1Node.html#a30d34fac51548633d6748b09f47a3d92" title="Saves the current node to a persistent store. ">save()</a>' and '<a class="el" href="classModel_1_1Node.html#a20246c48b754e0fceeb7c921f2f1f57b" title="Reloads this node from a persistent store. ">load()</a>' methods that specify how the node is stored in a persistent store.</p>
<p>A new class that derives from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> must define many standard methods and constructors. Many macros have been defined that greatly simplify this task. See 'nodeMacros.h' for more details.</p>
<p>A node in the tree has a revision number. Each time a node is created or loaded from a persistent store this number is reset to 0. Any modification to the node causes the revision to be incremented. This can be then used by visualizations or other plug-ins to track the evolution of node and update it necessary. A node's revision number will also increase when any of its descendants is modified, added or removed.</p>
<p>A node that supports partial loading, should reimplement the 'loadFully()' method to enable this functionality.</p>
<p>The functionality offered by the <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> class includes:</p><ul>
<li>Navigation routines between parents and children.</li>
<li>Navigation routines between different subtrees.</li>
<li>Revision control.</li>
<li>Persistent store interaction.</li>
<li>Meta information. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a29d3a7201bf31b72f1be907e7182484e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classModel_1_1Node.html">Node</a>*(* Model::Node::NodeConstructor) (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pointer type is used to register a constructor for nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node of the newly created node. This may be 'nullptr'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1eed04b65436277c4e970b6c20827b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classModel_1_1Node.html">Node</a>*(* Model::Node::NodePersistenceConstructor) (<a class="el" href="classModel_1_1Node.html">Node</a> *<a class="el" href="classModel_1_1Node.html#a0027c2328323a4733b3e594958b6998a">parent</a>, <a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;store, bool partialLoadHint)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function pointer type is used to register the constructor for nodes that are being loaded from a persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent node of the newly created node. This can be NULL to indicate that this node is the root node for the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a>. Otherwise it should be non-NULL. </td></tr>
    <tr><td class="paramname">id</td><td>The id of the node from the persistent store. </td></tr>
    <tr><td class="paramname">store</td><td>The store that is contains this node and its subtree. This will be used to load the children of the node. </td></tr>
    <tr><td class="paramname">partialLoadHint</td><td>A flag that hints whether this node should be fully or partially loaded. The constructor of the node is allowed to ignore this flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0e2e9bad8ff0ccde3c945aa359f81a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79">Model::Node::FindSymbolDirection</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a0e2e9bad8ff0ccde3c945aa359f81a79a442bce153404d787512d1392ba9000fa"></a>SEARCH_UP&#160;</td><td class="fielddoc">
<p>Looks for symbols within the specified scope and enclosing scopes. </p>
<p>Depending on the source, symbols in the current scope which come after the source will not be considered. This is the case e.g. with searches for local variable declarations in a method: only variables before the source node should be considered. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e2e9bad8ff0ccde3c945aa359f81a79ad32cc9e783e89ba6ffb83011a55abe97"></a>SEARCH_DOWN&#160;</td><td class="fielddoc">
<p>Looks for symbols inside the specified scope or subscopes. </p>
<p>This is used for symbols that are requested in a specific context (typically after a '.') e.g. "list.sort()" </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a0e2e9bad8ff0ccde3c945aa359f81a79ac0232fa9373d329c1b413b8058db0209"></a>SEARCH_HERE&#160;</td><td class="fielddoc">
<p>Looks for symbols defined by the current node. </p>
<p>This happens when findSymbols has been called on the parent with SEARCH_DOWN and the parent must therefore find a precise match in its scope. <a class="el" href="classModel_1_1Node.html#aa5949daf00c16bd91d7a5b64441f0fd4" title="Returns in result a set of all nodes which define a symbol with a name matching matcher in the scope ...">findSymbols()</a> will be called for each potential match from the parents children with the SEACH_HERE flag </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classModel_1_1Node.html#ade9aeda176a34521dc812ecf7a3d4626">Model::Node::SymbolType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626a64654d684ce9e1b176602e431e8f4ede"></a>UNSPECIFIED&#160;</td><td class="fielddoc">
<p>The default type of a node. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626a02e84a1c4f978e55c8b4bd8881046a3c"></a>METHOD&#160;</td><td class="fielddoc">
<p>Used for nodes which define methods. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626a31efe4c19e97f4901216833fcfa1624a"></a>CONTAINER&#160;</td><td class="fielddoc">
<p>Used for nodes which contain other symbol defining nodes, accessible by '. </p>
<p>' . </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626acb4740282468669ce6845a9ef6fbb8e7"></a>VARIABLE&#160;</td><td class="fielddoc">
<p>Used for global, local variables, arguments and fields. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ade9aeda176a34521dc812ecf7a3d4626a8ecd03bd1aae995d469430e3d033c5ba"></a>ANY_SYMBOL&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6026745a457fb0edde390e06c8168391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new node with the specified parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent of this node. This may be 'nullptr'.</td></tr>
  </table>
  </dd>
</dl>
<p>If the parent is not null, then the manager associated with the parent will also be the manager for this node. If the parent is nullptr, then this node will not be associated with a manager initially. It can later be added to an existing manager. </p>

</div>
</div>
<a class="anchor" id="a6a0c3ccbae8a426091c6a1679f16e730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Model::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Note that <em>other</em> is ignored and a copy will have no parent or manager and will have a revision of 0. </p>

</div>
</div>
<a class="anchor" id="ab93b813886967b6d93a351c75f31b6e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Model::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa33e411bb1aa1aabca6d162f66bc481f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1NodeReadWriteLock.html">NodeReadWriteLock</a> * Model::Node::accessLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the lock used to control access to this node. </p>
<p>If a node should represent a new access unit, this method should be overriden to return a lock associated with the node.</p>
<p>The default implementation just asks for the lock of the parent, or if the parent is NULL for the root lock of the manager. </p>

</div>
</div>
<a class="anchor" id="a72c0d0ffbf6398cc48fd6627ddab6cfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::addToRevision </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>valueToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the revision of this node by the specified amount. </p>

</div>
</div>
<a class="anchor" id="ae6c6fa88579de718cfc16e2a5c22e8e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::beginModification </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>QString()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a modification session with the current node as a modification target. </p>
<p><em>text</em> is the description that will be associated with this modification.</p>
<dl class="section see"><dt>See also</dt><dd>Model::beginModification() </dd></dl>

</div>
</div>
<a class="anchor" id="aa8c5add36bb451a75764b01b6cd15680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; Model::Node::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all child nodes. </p>
<p>Reimplement this method in derived classes that have children. The default implementation returns an empty list. </p>

</div>
</div>
<a class="anchor" id="a427c24fa5263d22e93b22f6060539843"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; Model::Node::childrenInScope </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all child nodes that may define symbols that form the scope of this node. </p>
<p>The default implementation returns all direct children of this node.</p>
<p>Reimplement this method to customize while nodes form the scope of this node. </p>

</div>
</div>
<a class="anchor" id="a3c2cc03d20d8332566a10a832bdef8e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; NodeType * &gt; Model::Node::childrenOfType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Model::Node</a> *&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all children including the node <em>from</em>, which have type <em>NodeType</em>. </p>

</div>
</div>
<a class="anchor" id="a36e9a04f8ca9bb1de7396e12c2803fd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static QList&lt;<a class="el" href="classModel_1_1Node.html">Model::Node</a>*&gt; Model::Node::childrenWhich </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Model::Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all children including the node <em>from</em>, which fullfill the <em>Predicate</em> <em>p</em>, i.e. </p>
<p><em>p(node)</em> returns true. </p>

</div>
</div>
<a class="anchor" id="a58662c38c52044cc2af67744d310f8cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt;<a class="el" href="classModel_1_1Node.html">Node</a>*&gt; Model::Node::childrenWhich </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c86ab8359212f69dcbafd1f40bd8aea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::childToSubnode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the direct child node that is equal to <em>other</em> or is an ancestor of <em>other</em>. </p>
<p>Returns null if this node is not an ancestor of <em>other</em>. </p>

</div>
</div>
<a class="anchor" id="a31d51c241cde5c82888b5e438ef02344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classModel_1_1Node.html">Node</a>* Model::Node::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6da5da50350c88318893b891940ccf60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::createDefaultInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> is an abstract class this method always returns nullptr. </p>

</div>
</div>
<a class="anchor" id="a0ca79f2a20d8993eea0e86ca6088da7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::createNewNode </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new node of the specified type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the node to create. This must be a type that has been registered before by calling registerNodeType.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the node. This may be 'nullptr'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12d7cfdf3abf4c1c2bbefc3654678805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::createNewNode </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>partialLoadHint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new node of the specified type by loading it from a persistent store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the node to create. This must be a type that has been registered before by calling registerNodeType.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of the node. This can be NULL if this is the root node.</td></tr>
    <tr><td class="paramname">store</td><td>The persistent store to use to load the subtree of this node.</td></tr>
    <tr><td class="paramname">partialLoadHint</td><td>Whether this node should only be partially loaded. This is only a hint and a node implementation can ignore this flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc19699b25363ba3474acf0000da4329"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::definesSymbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node defines a symbol and false otherwise. </p>
<p>The default implementaion returns false. Reimplement this method, <a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36" title="Returns the name of the symbol defined by this node. ">symbolName()</a>, and <a class="el" href="classModel_1_1Node.html#a8e7c22e6f01f3728581705da5298af16" title="Returns the type of the symbol defined by this node. ">symbolType()</a> in derived classes that define symbols. </p>

</div>
</div>
<a class="anchor" id="ad54d77f21d23364b560deeca22a6347e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::endModification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends a modification session. </p>
<dl class="section see"><dt>See also</dt><dd>Model::endModification() </dd></dl>

</div>
</div>
<a class="anchor" id="a9aad10e0ec7b9359f325db5a3c4fbf90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1UndoCommand.html">UndoCommand</a> *&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the specified command and pushes it on the undo stack. </p>
<p>This method will fail with an exception if the current thread does not hold the lock for this node's access unit.</p>
<p>This method also increments the revision of the node by 1. </p>

</div>
</div>
<a class="anchor" id="aa5949daf00c16bd91d7a5b64441f0fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::findSymbols </td>
          <td>(</td>
          <td class="paramtype">QSet&lt; <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html#a0e2e9bad8ff0ccde3c945aa359f81a79">FindSymbolDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolTypes&#160;</td>
          <td class="paramname"><em>symbolTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exhaustAllScopes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns in <em>result</em> a set of all nodes which define a symbol with a name matching <em>matcher</em> in the scope of this node. </p>
<p>The return value is true if a symbol was found and false otherwise.</p>
<p>The <em>source</em> <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> specifies what node should be used as a reference when determining what symbols are visible.</p>
<p>The <em>direction</em> specifies what search to perform.</p>
<p>The <em>symbolTypes</em> specifies what symbol types should be returned. If a symbol matches any of the requested types it will be returned.</p>
<p>If <em>exhaustAllScopes</em> is false, the search will halt as soon as symbols are found within a scope. This is useful when resolving links and it is important to find the "nearest" symbols that match with respect to scope. If <em>exhaustAllScopes</em> is true, the search will explore all scopes in corresponding to the provided mode. This is useful when <em>symbolExp</em> can match multiple symbols with different names (for example during auto completion list build up).</p>
<p>The default implementation returns a set with only the current node in it, in case the node defines the requested symbol. Otherwise if <em>mode</em> is FindSymbolMode::SEARCH_UP, the implementation of the parent node is called.</p>
<p>Reimplement this method in derived classes to specify fine grained behavior and operation for search modes other than FindSymbolMode::SEARCH_UP </p>

</div>
</div>
<a class="anchor" id="ab783131a246c62272ec2e89fb812834b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeType * Model::Node::firstAncestorOfType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first Ancestor which has the type <em>NodeType</em> if there is one, otherwise null. </p>

</div>
</div>
<a class="anchor" id="acf82e31f88ef1b7b899995a8e4510fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::firstAncestorOfType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;&#160;</td>
          <td class="paramname"><em>typeMatch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first Ancestor for which typeName() matches with <em>typeMatch</em>, if there is one, otherwise null. </p>

</div>
</div>
<a class="anchor" id="a6b7e6b348411ba66c33eb93fb855aeb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::hasPartiallyLoadedChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is partially loaded or has partially loaded children. </p>

</div>
</div>
<a class="anchor" id="a410cafa4e196e8f572d6f24992bfc914"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::incrementRevision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the revision of this node by 1. </p>

</div>
</div>
<a class="anchor" id="a9fdb27f1c721bd3d89c7881dabd7efc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isAncestorOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true of this node is an Ancestor of other and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a78e99d1b37afb4ca5575d68391cc0455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isModifyable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true is the this node can be modified or false otherwise. </p>
<p>A node is modifiable if it is part of an access unit which is currently acquired by a writer thread. This is managed by the <a class="el" href="classModel_1_1TreeManager.html" title="The TreeManager class is a management and access entity for a program tree. ">TreeManager</a> associated with the node.</p>
<p>If a node does not have an associated manager it is always modifiable. </p>

</div>
</div>
<a class="anchor" id="a3acc47bd4c6dcda029cbcc91a12315e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isNewPersistenceUnit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node should be persisted in a new persistence unit. </p>
<p>This is typically a per class value.</p>
<p>When the user saves the project normally the entire corresponding application tree is saved. To optimize the amount of data written to disk, it is possible to indicate new persistence units. Whenever a node in the application is modified only the persistent unit it belongs to, together with all persistence units of its parents are saved.</p>
<p>For example, to simulate the typical scenario of saving classes in different files, a node which represents a class should return true as the result of this method.</p>
<p>NOTE: The persistence engine will save the ID and last revision of all objects that which are marked as a new persistence unit. Therefore this option should be used with care. Only node types closer to the root are suitable for being new persistence units. Nodes closer to the leafs, such as expressions and text values should not be new persistence units, as this will greatly increase the memory required by the persistence engine. </p>

</div>
</div>
<a class="anchor" id="a480f996764f0f65c60d2fdeff3d7a91d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isPartiallyLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node is only partially loaded. </p>
<p>In order for this method to work as expected, the constructors of nodes which are only partially loaded should call the <a class="el" href="classModel_1_1Node.html#aa057da12df8ca1b205e4556a5e1ec655">setPartiallyLoaded()</a> method. </p>

</div>
</div>
<a class="anchor" id="a5dbd7d3b65eaa81a451389a9db3aaa3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isTransparentForNameResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node should propagate name resolution requests through it, as if were not there. </p>
<p>The default implementaion returns false. Reimplement this method in sub classes that are not part of name resolution, but are involved in the process (e.g. lists or projects). By default, a non-transparent object will prevent name resolution from propagating past it, if it does not match the name being searched for. </p>

</div>
</div>
<a class="anchor" id="abce3db1f4cf4cf5192694631148aebcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::isTypeRegistered </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there are already registered constructs for a type with the specified name and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a20246c48b754e0fceeb7c921f2f1f57b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Model::Node::load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reloads this node from a persistent store. </p>
<p>This method is called at any point after this node has been created in order to reinitialize its contents from the persistent store. Any existing subtree should be gracefully detached. This means that subtrees should not be deleted, but simply detached from the current node in a reversible way using commands that can be undone. </p>

</div>
</div>
<a class="anchor" id="ae5e3b8c2c318384183aa27971e3ac59f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::lowestCommonAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> **&#160;</td>
          <td class="paramname"><em>thisParent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> **&#160;</td>
          <td class="paramname"><em>otherParent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the lowest common ancestor of this node and other. </p>
<p>If <em>thisParent</em> and <em>otherParent</em> are provided, they will be set to the last ancestors of <em>this</em> and <em>other</em> which are different from each other and have the common ancestor as parent. If there is no common parent, these will be set to the roots of the corresponding trees. If <em>this</em> == <em>other</em>, <em>thisParent</em> and <em>otherParent</em> are set to nullptr. </p>

</div>
</div>
<a class="anchor" id="ab0ec6807ca4e9e48845bfd44ca946195"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a> * Model::Node::manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tree manager of the current <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>. </p>
<p>Calling this method during the creation of the root <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> will return a nullptr. </p>

</div>
</div>
<a class="anchor" id="a0027c2328323a4733b3e594958b6998a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> or NULL if this is the root. </p>

</div>
</div>
<a class="anchor" id="ace3a8ec46cff8d318fc2da397b710862"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QSet&lt; const <a class="el" href="classModel_1_1Node.html">Node</a> * &gt; &amp; Model::Node::partiallyLoadedNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a38b8c8cba2f1ec245a6565436b40693b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::persistentUnitNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node that defines the persistence unit for this node. </p>

</div>
</div>
<a class="anchor" id="a4b556959f8eb58b5e0ad2c154700e810"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::propagateManagerToChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae241d587f6660096695f8e714e5008fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::registerNodeType </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html#a29d3a7201bf31b72f1be907e7182484e">NodeConstructor</a>&#160;</td>
          <td class="paramname"><em>constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classModel_1_1Node.html#ac1eed04b65436277c4e970b6c20827b0">NodePersistenceConstructor</a>&#160;</td>
          <td class="paramname"><em>persistenceconstructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the constructors of a class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>. </p>
<p>Each class derived from <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a> must be registered before it can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The string name of the class. </td></tr>
    <tr><td class="paramname">constructor</td><td>A function that can construct a new instance of the class at run-time. </td></tr>
    <tr><td class="paramname">persistenceconstructor</td><td>A function that can construct a new instance of the class from a persistent store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98f7e4d0475077b671b7ee108e937593"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::replaceChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>replacement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the child item <em>child</em> with the item <em>replacement</em> and returns true on success. </p>
<p>The default implementation always returns false and is suitable for nodes without children. Reimplement this method if you are implementing a composite node that has replaceable child nodes. </p>

</div>
</div>
<a class="anchor" id="a868e082304e233d32dde632280c99241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Model::Node::revision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the revision of this node. </p>

</div>
</div>
<a class="anchor" id="a78ce4ee82d2c0ed0b211fa29aec22923"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a> * Model::Node::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the root node of tree where of this node. </p>

</div>
</div>
<a class="anchor" id="a30d34fac51548633d6748b09f47a3d92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Model::Node::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1PersistentStore.html">PersistentStore</a> &amp;&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the current node to a persistent store. </p>
<p>This method should contain calls to the store object that persist the subtree of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The persistent store to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0662a376982b4cce855e731a0d8134a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the parent of this <a class="el" href="classModel_1_1Node.html" title="The Node class is the foundation element in the tree in Envision. ">Node</a>. </p>

</div>
</div>
<a class="anchor" id="aa057da12df8ca1b205e4556a5e1ec655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::setPartiallyLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5b3b92f33676eef70c7c7ce525ad97f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Model::Node::setRootManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the manager of this root node to <em>manager</em>. </p>
<p>This node must not have a parent. </p>

</div>
</div>
<a class="anchor" id="a02456394b3aa6526a11ff61cd4e6fcfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Model::Node::symbolMatches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classModel_1_1SymbolMatcher.html">SymbolMatcher</a> &amp;&#160;</td>
          <td class="paramname"><em>matcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SymbolTypes&#160;</td>
          <td class="paramname"><em>symbolTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this node defines a symbol that has a name matching <em>matcher</em> and types common with <em>symbolTypes</em>. </p>

</div>
</div>
<a class="anchor" id="ac0238f80b3ad5960919e56e959fb8b36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const QString &amp; Model::Node::symbolName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the symbol defined by this node. </p>
<p>The default implementaion returns a null QString value. Reimplement this method, <a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329" title="Returns true if this node defines a symbol and false otherwise. ">definesSymbol()</a>, and <a class="el" href="classModel_1_1Node.html#a8e7c22e6f01f3728581705da5298af16" title="Returns the type of the symbol defined by this node. ">symbolType()</a> in derived classes that define symbols. </p>

</div>
</div>
<a class="anchor" id="a8e7c22e6f01f3728581705da5298af16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node::SymbolTypes Model::Node::symbolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the symbol defined by this node. </p>
<p>The default implementaion returns UNSPECIFIED. Reimplement this method, <a class="el" href="classModel_1_1Node.html#ac0238f80b3ad5960919e56e959fb8b36" title="Returns the name of the symbol defined by this node. ">symbolName()</a>, and <a class="el" href="classModel_1_1Node.html#acc19699b25363ba3474acf0000da4329" title="Returns true if this node defines a symbol and false otherwise. ">definesSymbol()</a> in derived classes that define symbols. </p>

</div>
</div>
<a class="anchor" id="a283efe5bf4f53d649a1ae1b1adf3dc0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Model::Node::toDebugString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this node to a string for use in debug purposes only. </p>
<p>This method uses the adapter framework and tries to convert this node to a QString. </p>

</div>
</div>
<a class="anchor" id="afceaa207bf87136fe98fe490a063b144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; const <a class="el" href="classModel_1_1UsedLibrary.html">UsedLibrary</a> * &gt; Model::Node::usedLibraries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of all libraries that are used by this node and its subnodes. </p>
<p>This method should be called on root nodes, as once a node specifies a used library, its children no longer need to specify it.</p>
<p>The default implementation simply recursively calls the same method for all children and returns a combined list. This implementation is sufficient for correct operation, but derived classes can nevertheless override this method in order to prune the search tree. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a617cdb5ee1a5c38e2a29716b4a84b15e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1TreeManager.html">TreeManager</a>* Model::Node::manager_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa9eb8e52cbbb0369643a683ac9d5ce0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QHash&lt; QString, <a class="el" href="classModel_1_1Node.html#a29d3a7201bf31b72f1be907e7182484e">Node::NodeConstructor</a> &gt; Model::Node::nodeConstructorRegister</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ccb5dd46db0cc4e08f1aea6b982b6d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QHash&lt; QString, <a class="el" href="classModel_1_1Node.html#ac1eed04b65436277c4e970b6c20827b0">Node::NodePersistenceConstructor</a> &gt; Model::Node::nodePersistenceConstructorRegister</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3a6f51536abb137ede5c427725222d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classModel_1_1Node.html">Node</a>* Model::Node::parent_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7cec2acbdfb8620d4901ada5600faacd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Model::Node::revision_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
